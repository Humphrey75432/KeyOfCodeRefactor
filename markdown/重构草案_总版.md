[TOC]

# 0 描述重构手法的一种草案格式

## 重构名称

**【重构概要】** 简要介绍重构手法的适用场景以及所能在实际环境中解决的问题;

**【重构动机】** 需要使用该重构来完成代码整理的动机以及时机，如有确定的一些特征也可以罗列在下方;

**【重构做法】** 说明重构执行的每个具体步骤。格式如下：

1. 重构的第一个步骤；
2. 重构的第二个步骤；

**【重构前范例】** 使用一段示例代码展示重构前的代码结构以及存在的问题;

```java
public class BeforeRefactor {
    public void beforeMethod() {
        // ... 重构之前的代码结构
    }
}
```

**【重构后范例】** 使用一段示例代码展示重构后的代码结构以及实现的效果;

```java
public class AfterRefactor {
    public void afterMethod() {
        // ...重构之后的代码结构
    }
}
```

# 1 重新组织函数

## 1.1 提炼函数（Extract Method）

**【重构概要】** 将一段代码放进一个独立函数，并让函数名称解释函数的用途；

**【重构动机】** 一个过长的函数或者需要一段注释才能让人理解用途的代码，使用一个独立函数来解释代码的用途；

**【重构做法】**

1. 提取需要抽到新函数中的代码片段；
2. 将提取出来的代码片段放入新函数中；
3. 删除步骤1的代码片段，替换成步骤2中的新函数；
4. 运行并测试，验证重构后是否保持一样的行为；

**【重构前范例】**

```java
public class RefactorClass {
    public void printOwing(String name, double amount) {
        printBanner();
        /* 提取以下两行代码并抽至新函数printAmount中 */
        System.out.println("name: " + name);
        System.out.println("amount: " + amount);
    }
}
```

**【重构后范例】**

```java
public class RefactorClass {
    public void printOwing(String name, double amount) {
        printBanner();
        /* 注释原有的两行代码，改调用新函数，查看效果 */
        // System.out.println("name: " + name);
        // System.out.println("amount: " + amount);
        printAmount(String name, double amount);
    }
    
    /* 创建新函数printAmount */
    private void printAmount(String name, double amount) {
        System.out.println("name: " + name);
        System.out.println("amount: " + amount);
    }
}
```

## 1.2 内联函数（Inline Method）

**【重构概要】** 一个函数本体与其名称同样清楚易懂，在函数调用点插入函数本体并移除函数本身；

**【重构动机】** 在函数的内部代码与函数名称同样清晰易读的情况下，应当直接用函数本体，而不是使用一个短小函数对其做过度包装；

**【重构做法】**

1. 检查需要修改的函数，确定其不具备多态性；
2. 找出该函数的所有被调用点并将其调用点替换为函数本体；
3. 编译以及测试，确定不造成副作用后移除旧代码；

**【重构前范例】**

```java
public class RefactorClass{
    public int getRatings() {
        /* 检查待修改函数，找到调用点 */
        return (moreThanFiveLateDeliveries()) ? 2 : 1;
    }
    
    private boolean moreThanFiveLateDeliveries() {
        /* 函数本体和函数名称一样清晰可懂 */
        return numberOfLateDeliveries > 5;
    }
}
```

**【重构后范例】**

```java
public class RefactorClass {
    public int getRatings() {
        /* 替换函数调用点为函数本体 */
        return numberOfLateDeliveries > 5;
        /* 移除旧调用点，编译测试 */ 
        // return (moreThanFiveLateDeliveries()) ? 2 : 1;
    }
}
```

## 1.3 内联临时变量（Inline Temporary Variable）

**【重构概要】** 将所有对该变量的引用动作，替换成对它赋值的那个表达式本身

**【重构动机】** 当某个临时变量被赋予某个函数调用的返回值，如果它的存在会妨碍其他重构手法时，就应当对其进行重构；

**【重构做法】**

1. 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用；
2. 如果该临时变量未被声明为final，就将其声明为final，然后编译；
3. 找到该临时变量的所有引用点，将其替换成“为临时变量”赋值的表达式；
4. 修改完成后编译、测试、并删除该临时变量的声明和赋值语句；

**【重构前范例】**

```java
/* 函数本体和函数名称一样简单易懂 */
double basePrice = anOrder.basePrice();
return (basePrice > 1000);
```

**【重构后范例】**

```java
/* 替换函数名称为函数本体中的内容 */
return (anOrder.basePrice() > 1000);
```

## 1.4 以查询取代临时变量（Replace Temporary with Query）

**【重构概要】** 将临时变量保存德表达式提炼到一个独立函数中，将这个临时变量德所有引用点替换为新函数德调用。此后，新函数就可以被其他函数所使用。

**【重构动机】** 临时变量只在所属函数内使用，因此对外来说是不可见的。为了使得其他函数能够见到同属的一份信息，可以将临时变量替换为一个查询。

**【重构做法】**

1. 找出只被赋值一次的临时变量，将其声明为final进行编译；
2. 将『对该临时变量赋值』的语句登号右侧部分提炼到一个独立函数；

**【重构前范例】**

```java
double basePrice = quantity * itemPrice;
if (basePrice > 1000) {
  return basePrice * 0.95;
} else {
  return basePrice * 0.98;
}
```

**【重构后范例】**

```java
if (basePrice > 1000) {
  basePrice() * 0.95;
} else {
  basePrice() * 0.98;
}

double basePrice() {
  return quantity * itemPrice;
}
```

## 1.5 引入解释性变量（Introduce Explaining Variable）

**【重构概要】** 将复杂表达式（或其中的一部分）的结果放进一个临时变量，以此变量名称来解释表达式的用途；

**【重构动机】** 表达式可能非常复杂难以阅读，临时变量可以帮助表达式分级为比较容易管理和理解的形式；

**【重构做法】**

1. 声明一个final变量，将待分解的复杂表达式中的一部分动作的运算结果赋值给他；
2. 将表达式中的『运算结果』中的一部分替换为上述的临时变量；
3. 编译，测试并重复上述步骤；

**【重构前范例】**

```java
if (platform.toUpperCase().indexOf("MAC") > -1 &&
   platform.toUpperCase().indexOf("IE") > -1 &&
   wasInitialized() $$ resize > 0) {
  // do something
}
```

**【重构后范例】**

```java
final boolean isMacOS = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = platform.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize > 0;
if (isMacOS && isIEBrowser && wasInitialized() && wasResized) {
  // do something
}
```

## 1.6 分解临时变量（Split Temporary Variable）

**【重构概要】** 针对每一次赋值，创建一个独立、对应的临时变量；

**【重构动机】** 某些对临时变量的用途有可能导致临时变量被多次赋值，例如循环变量会随着循环的每次进行而改变；结果收集变量会将整个函数的运算构成某个数值后再收集起来。多次被赋值的临时变量承担了多重责任，就应当被替换分解诚多个临时变量，每个变量值承担一个责任；

**【重构做法】**

1. 在待分解临时变量的声明以及第一次被赋值处修改其名称，并将新的临时变量声明为final；
2. 以该临时变量的第二次赋值动作为界限，修改此前对该临时变量的所有引用点，让它们引用新的临时变量；
3. 编译、测试并重复前述步骤；

**【重构前范例】**

```java
/* 临时变量第一次被创建以及赋值的地方，此时temp表示周长 */
double temp = 2 * (height + width);
System.out.println(temp);
/* 临时变量第二次被赋值的地方，此时temp表示面积 */
temp = height * width;
System.out.println(temp);
```

**【重构后范例】**

```java
/* 将第一次赋值的地方命名为perimeter，并用final修饰 */
final double perimeter = 2 * (height + width);
System.out.println(perimeter);
/* 将临时变量第二次赋值的地方命名为area，并用final修饰 */
final double area = height * width;
System.out.println(area);
/* 后续如有类似的代码使用同样的方法进行修改 */
```

## 1.7 移除对参数的赋值（Remove Assignments to Parameters）

**【重构概要】** 用一个临时变量取代该参数的位置；

**【重构动机】** 如果代码的语义是按引用传递的，就在调用端检查调用后是否使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。尽量使用一个return来返回一个值。如果返回值比较多，可以将返回的数据封装成一个对象，或者干脆为每一个返回值设置一个独立函数；

**【重构做法】**

1. 建立一个临时变量，把待处理的参数值赋予它；
2. 以『对参数赋值』为界，将其后所有对此参数的引用点，全部替换成『对此临时变量』的引用；
3. 修改赋值语句，使其改为对新建的临时变量赋值；

**【重构前范例】**

```java
int discount(int putVal, int quantity, int yearToDate) {
  if (putVal > 50) putVal -= 2;
}
```

**【重构后范例】**

```java
int discount(int putVal, int quantity, int yearToDate) {
  int result = inputVal;
  if (result > 50) result -= 2;
}
```

## 1.8 以函数对象取代函数（Replace Method with Method Object）

**【重构概要】** 将这个函数放进一个单独对象中，局部变量变成对象内的字段。这样就可以再同一个对象中将大型函数分解成诸多个小型函数；

**【重构动机】** 局部变量会增加函数分解的难度，通常情况下会使用Replace Temporary with Query消除局部变量。一旦该方法失效，就应当使用对象来取代函数。该方法的核心是将所有的局部变量都变成函数的对象字段。然后在抽取的对象中使用Extract Method创造出新函数。从而将原本的大型函数拆解成短小函数；

**【重构做法】**

1. 建立一个新类，根据待处理函数的用途，为这个类命名；
2. 在新类中建立一个final字段，用以保存原先大型函数所在的对象，该对象称之为『源对象』，同时针对原函数的每个临时变量和每个参数，在新类中建立一个对应字段保存；
3. 在新类中建立构造函数，接收源对象以及原函数的所有参数作为参数；
4. 在新类中建立一个compute函数，并将原函数中的代码赋值到compute函数中，如果需要调用源对象中的任何函数，可以通过源对象字段调用；
5. 编译；

**【重构前范例】**

```java
class Account {
  int gamma(int inputVal, int quantity, int yearToDate) {
    int importantValue1 = (inputVal * quantity) + delta();
    int importantValue2 = (inputVal * yearToDate) + 100;
    if (yearToDate - importantValue1 > 100) {
      importantValue2 -= 20;
    }
    int importantValue3 = importantValue2 * 70;
    return importantValue3 - 2 * imporantValue1;
  }
}
```

**【重构后范例】**

```java
class Account {
  int gamma(int intputVal, int quantity, int yearToDate) {
    return new Gamma(this, inputVal, quantity, yearToDate).compute();
  }
}

/* 创建新类 */
class Gamma {
  /* 创建源对象 */
  private final Account account;
  private final int inputVal;
  private final int quantity;
  private final int yeatToDate;
  
  /* 创建原函数中的临时变量字段 */ 
  private final int importantValue1;
  private final int importantValue2;
  private final int importantValue3;
  
  /* 创建构造函数，接受源对象以及源对象字段 */
  public Gamma(Account account, int inputValue, int quantity, int yearToDate) {
    this.account = account;
    this.inputVal = inputVal;
    this.quantity = quantity;
    this.yearToDate = yearToDate;
  }
  
  /* 创建compute方法，搬移原函数中的相应逻辑 */ 
  public int compute() {
    int importantValue1 = (intputVal * quantity) + delta();
    int importantValue2 = (intputVal * yearToDate) + 100;
    /* 调用拆解出来的新函数 */
    importantThing()
    int importantValue3 = importantValue2 * 7;
    return importantValue3 - 2 * importantValue1;
  }
  
  /* 使用Extract Method对compute函数做拆解 */
  void importantThing() {
    if ((yearToDate - importantValue1) > 100) {
      importantValue2 -= 20;
    }
  }
}
```

## 1.9 替换算法（Substitute Algorithm）

**【重构概要】** 将函数本体替换成另外一种算法

**【重构动机】** 如果做一件事情可以有更加清晰的方式，就应该使用更清晰的方式代替复杂的方式。替换的前提需要把复杂的大代码块替换成简单的小块，再进行替换；

**【重构做法】**

1. 准备替换用的算法；
2. 针对现有测试，执行上述新算法，如果重构后的结果与原本相同，重构结束；
3. 如果测试结果不同于原先，在测试和调试的过程中，以旧算法作为比较参照标准；

**【重构前范例】**

```java
String foundPerson(String[] people) {
  for (int i = 0; i < people.length; i++) {
    if (people[i].equals("Don")) {
      return "Don";
    }
    if (people[i].equals("John")) {
      return "John";
    }
    if (people[i].equals("Kent")) {
      return "Kent";
    }
  }
  return "";
}
```

**【重构后范例】**

```java
String foundPerson(String[] people) {
  List candidates = Arrays.asList(new String[]{"Don", "John", "Kent"});
  for (int i = 0; i < people.length; i++) {
    if (candidates.contains(people[i])) {
      return people[i];
    }
  }
  return "";
}
```

# 2 在对象之间搬移特性

## 2.1 搬移函数（Move Method）
**【重构概要】** 在该函数最常引用的类中建立一个有着类似行为的新函数，并将旧函数变成一个单纯地委托函数，或者是完全移除旧函数；

**【重构动机】** 一个类有太多行为或者两个类之间高度耦合，就需要尝试搬移函数。需要搬移的函数一般具备这样的特点：使用另一个对象的次数比使用自己所驻对象的次数还多。那么这种类型的函数就是可移动的。并且观察这个函数与哪边的交流比较多，救尝试把它搬移到哪边；

**【重构做法】**

1. 检查源类中被源函数所使用的一切特性（包括字段和函数），考虑其是否应该被搬移；
2. 检查源类的子类和超类，看看是否还有该函数的其他声明；
3. 在目标中使用新函数；
4. 将源函数的代码复制到目标函数中并调用后者，使其在新家中能够正常运行；
5. 编译目标类，并决定如何从源函数正确引用目标对象；
6. 修改源函数，使之成为一个纯委托函数；
7. 编译、测试；
8. 决定是否删除源函数，或将它变成一个委托函数保留下来；
9. 如果要删除函数，将源类中对源函数的所有调用替换成对目标函数的调用；
10. 编译、测试；

**【重构前范例】**

```java
class Account {
    /* 现在有多个Account，每个Account都有属于自己的"透支金额计费规则" */
    /* 决定将overdraftCharge方法迁移到AccountType类中 */
    double overdraftCharge() {
        if (type.isPremium()) {
            double result = 10;
            if (daysOverdraft > 7) {
                result += (daysOverdraft - 7) * 0.85;
                return result;
            }
            retuen daysOverdraft * 1.75;
        }
    }
    
    double bankCharge() {
        double result = 4.5;
        if (daysOverdraft > 0) {
            result += overdraftCharge;
        }
        return result;
    }
    private AccountType type;
    private int overdraftCharge;
}
```

**【重构后范例】**

```java
class AccountType {
    /* 将原属于Account中的函数搬移到AccountType中 */
	double overdraftCharge(int daysOverdrawn) {
		if (isPremium()) {
			double result = 10;
			if (daysOverdrawn > 7) {
				result += (daysOverdrawn - 7) * 0.85;
				return result;
			}
		}
		return daysOverdrawn * 1.75;
	}
}

class Account {
	double bankCharge() {
        /* 将源函数的本体替换成另一个函数的简单委托 */
		return type.overdraftCharge(daysOverdrawn)
	}
	AccountType type;
	private int daysOverdrawn;
}
```

## 2.2 搬移字段（Move Field）
**【重构概要】** 在目标新类中建立一个字段，修改源字段的所有用户，令它们改用新字段；

**【重构动机】** 对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就需要考虑搬移该字段，所谓的“使用”可能是通过设置/取值函数间接进行的；

**【重构做法】**

1. 如果字段访问级别是public，使用封装字段（Encapsulate Field）将其封装起来，并编译测试；
2. 在目标类中建立源字段相同的字段，并同时建立相应的设置/取值函数；
3. 编译目标类，决定如何在源对象中引用目标对象；
4. 删除源字段，将所有对源字段的引用替换成对某个目标函数的调用；
5. 将所有对源字段的引用替换成对某个目标函数的调用；
6. 编译、测试；

**【重构前范例】**

```java
class Account {
    private AccountType type;
    /* 将interestRate搬移到AccountType类中 */
    private double interestRate;
    
    double interestForAmountDays(double amount, int days) {
        return interestRate * amount * days / 365;
    }
}
```

**【重构后范例】**

```java
class Account {
    private AccountType type;
    /* 将interestRate搬移到AccountType类中 */
    @Deprecated
    private double interestRate;
    
    double interestForAmountDays(double amount, int days) {
        /* 先用自封装的getter方法替换待迁移的变量 */
        // return getInterestRate() * amount * days / 365;
        return type.getInterestRate() * amount * days / 365;
    }
    
    /* 自我封装 */
    /* 自封装方法可以在所有搬移字段都迁移完毕后直接删除 */
    @Deprecated
    void setInterestRate(double interestRate) {
        this.interestRate = interestRate;
    }
    
    @Deprecated
    double getInterestRate() {
        return interestRate;
    }
}

class AccountType {
    /* 将待搬移的字段抽到新类中 */
	private double interestRate;
	
    /* 对新类中的字段做自封装 */
	public void setInterestRate(double interestRate) {
		this.interestRate = interestRate;
	}

	public double getInterestRate() {
		return interestRate;
	}
}
```

## 2.3 提炼类（Extract Class）
**【重构概要】** 建立一个新类，将相关的字段和函数从旧类搬移到新类；

**【重构动机】** 一个类应当是一个清楚的抽象，处理一些明确的职责。但随着职责的不断增加，类会变得越来越复杂。这种含有大量函数和数据的类往往是非常不容易理解的。此时你就需要考虑将哪些职责搬移出去，哪些职责保留在本类中。一个有用的测试就是询问自己：如果你搬移了某个函数和字段，会发生什么事情。

**【重构做法】**

1. 决定分解类所负的职责；
2. 建立一个新类，用以表现从旧类中分离出来的责任；
3. 建立“从旧类访问新类”的连接关系；
4. 对于你想搬移的每一个字段使用“搬移字段（Move Field）”方法；
5. 每次搬移后，编译、测试；
6. 使用Move Method将必要函数搬移到新类，先搬移较低层次的函数，再搬移较高层次的函数；
7. 每次搬移之后，编译、测试；
8. 检查每个类的接口；
9. 决定是否公开新类，如果明确公开，就决定让其成为引用对象还是不可变对象；

**【重构前范例】**

```java
class Person {
    private String name;
    private String officeAreaCode;
    private String officeNumber;

    public String getName() {
        return name;
    }
    
    /* 准备将电话号码的行为抽到一个独立的类中 */
    public String getTelephoneNumber() {
        return "(" + officeAreaCode + ")" + officeNumber;
    }

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

**【重构后范例】**

```java
class Person {
    private String name;
    // private String officeAreaCode;
    // private String officeNumber;
    private TelephoneNumber officeTelephoneNumber = new TelephoneNumber();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTelephoneNumber() {
        return "(" + officeTelephoneNumber.getOfficeAreaCode() + ")" + officeTelephoneNumber.getOfficeNumber();
    }
}

/* 创建一个新类TelephoneNumber */
class TelephoneNumber {
    /* 抽取officeAreaCode和officeNumber */ 
    private String officeAreaCode;
    private String officeNumber;

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

## 2.4 将类内联化（Inline Class）

【重构概要】 将这个类的所有特性搬移到另一个类中，然后移除原类；

【重构动机】如果一个类正好不再承担足够的责任、不再有单独存在的理由（通常是此前的重构动作搬走了这个类的责任），就会挑这个“萎缩类”的最频繁用户；将其塞入用户类中；

【重构做法】

1. 在目标类身上生命源类的public协议，并将其中所有函数委托至源类；
2. 修改所有源类引用点，改用引用目标类；
3. 编译、测试；
4. 使用Move Method和Move Field将源类的特性全部搬移到目标类；
5. 为源类举行一个“简单的丧礼”；

【重构前范例】

```java
class Person {
    private String name;
    // private String officeAreaCode;
    // private String officeNumber;
    private TelephoneNumber officeTelephoneNumber = new TelephoneNumber();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTelephoneNumber() {
        return "(" + officeTelephoneNumber.getOfficeAreaCode() + ")" + officeTelephoneNumber.getOfficeNumber();
    }
}

/* TelephoneNumber这个类和Person类是分离开的 */
class TelephoneNumber {
    /* 抽取officeAreaCode和officeNumber */ 
    private String officeAreaCode;
    private String officeNumber;

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

【重构后范例】

```java
class Person {
    private String name;
    private String officeAreaCode;
    private String officeNumber;

    public String getName() {
        return name;
    }
    
    /* 准备将电话号码的行为抽到一个独立的类中 */
    public String getTelephoneNumber() {
        return "(" + officeAreaCode + ")" + officeNumber;
    }

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

## 2.5 隐藏『委托』关系（Hide Delegate）

【重构概要】 在服务类上建立客户所需的所有函数，用以隐藏委托关系；

【重构动机】 如果某个客户先通过服务对象得到另一个对象，然后调用后者的函数，那么客户就必须知道这一层的委托关系。万一委托关系发生变化，客户也需要做出相应的变化；此时就需要将委托关系隐藏起来，以此去除这种依赖关系。如此一来即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及用户；

【重构做法】

1. 对于每一个委托关系中的函数，在服务对象端创建一个简单的委托函数；
2. 调整客户，令它只调用服务对象提供的函数；
3. 每次调整后，编译并测试；
4. 如果将来不再有任何客户需要使用委托类，直接移除服务对象中相关的访问函数；
5. 编译、测试；

【重构前范例】

```java
class Person {
  Department department;
  
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 假使客户John想要知道Manager是谁，必须先要知道对应的Department */
manager = john.getDepartment().getManager();
```

【重构后范例】

```java
class Person {
  Department department;
  
  /* 只要Person中不再使用这个函数，就可以将其从Person中删除 */
  @Deprecated
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  /* 建立Department类中的委托函数 */
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 改用Person的所有用户，改用新函数 */
manager = john.getManager();
```

## 2.6 移除中间人（Remove Middle Man）

【重构概要】 让客户直接调用受托类；

【重构动机】 使用“隐藏委托（Hide Delegate）”可以帮助我们将不必要的委托隐藏起来，但是其副作用也是十分明显的。每当客户要使用受托类的新特性时，必须要相应地在服务端添加一个简单委托函数。随着受托类的功能越来越多，服务类完全变成一个“中间人”，此时应该直接让客户调用受托类；

【重构做法】

1. 建立一个函数，用以获得受托对象；
2. 对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象；
3. 处理每个委托函数后，编译、测试；

【重构前范例】

```java
class Person {
  Department department;
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 为了找出John的经理，现在代码实现是这样的 */
manager = john.getManager();
```

【重构后范例】

```java
class Person {
  Department department;
  
  /* 创建getDepartment委托函数 */
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  /* 去除getManager的受托函数 */
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 为了找出John的经理，现在可以通过调用getDepartment方法得到Manager */
manager = john.getDepartment().getManager();
```

## 2.7 引入外加函数（Introduce Foreign Method）

【重构概要】 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例；

【重构动机】 为本不属于待修改的服务类中添加需要提供的职责，超出服务类本身职责的函数称之为外加函数。外加函数必须保证通用性，如果在系统中有多处调用，则要考虑将外加函数做成公共模块；

【重构做法】

1. 在客户类中建立一个函数，用来提供你需要的功能；
2. 以服务类实例作为该函数的第一个参数；
3. 将该函数注释为“外加函数，应在服务类中实现”；

【重构前范例】

```java
/* 将赋值运算符的右侧提炼到独立函数nextDay中 */
Date newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() + 1);
```

【重构后范例】

```java
Date newStart = nextDay(previousEnd);
private static Date nextDay(Date arg) {
    new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() + 1);
}
```

## 2.8 引入本地扩展（Introduce Local Extension）

【重构概要】 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类；

【重构动机】 类的作者无法预知未来，如果需要额外的函数超过两个，外加函数则无法控制这种变化。因此需要将这些函数组织到一起，放到一个恰到的地方。这个时候就需要使用本地扩展（子类化或包装）；

【重构做法】

1. 建立一个扩展类，将它作为原始类的子类或包装类；

2. 在扩展类中加入**转型构造函数**；

   > 转型构造函数：接受原对象作为参数的构造函数，如果是用子类化方法，转型构造函数应该调用适当的超类构造函数；如果使用包装方法，那么转型构造函数应当将它得到的传入参数以实例变量的形式保存起来，用作接受委托的原对象；

3. 在扩展类中加入新特性；

4. 根据需要将原对象替换为扩展对象；

5. 将针对原始类定义的所有外加函数搬移到扩展类中；

【重构前范例】

```java
// 以扩展JDK中的Date类为例 -- JDK8以下的特性
```

【重构后范例】

```java
/* 使用子类方式扩展 */
class MfDateSub extends Date {
    public MfDateSub nextDay() {...}
    public int dayOfYear() {...}
    
    /* 创建构造转型函数 */
    public MfDateSub(Date arg) {
        super(arg.getTime());
    }
    
    public MfDateSub(String dateString) {
        super(dateString);
    }
    
    /* 在扩展类中添加新特性 */
    private static Date nextDay(Date arg) {
        return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
    }
}

/* 使用包装方式扩展 */
class MfDateWrap {
    private Date original;
    
    public MfDateWrap(String dateString) {
        original = new Date(dateString);
    }
    
    /* 创建转型构造函数 */    
    public MfDateWrap(Date arg) {
        original = arg;
    }
    
    public ine getYear() {
        return original.getYear();
    }
    
    public boolean equals(Object arg) {
        if (this == arg) {
            return true;
        }
        if (!(arg.instanceof(MrDateWrap))) {
            return false;
        }
        MfDateWrap other = ((MfDateWrap)arg);
        return (original.equals(other.original));
    }
}
```

# 3 重新组织数据

## 3.1 自封装字段（Self Encapsulate Field）

【重构概要】为这个字段建立取值/设值函数，并且只以这些函数来访问字段；

【重构动机】如果想访问超类中的一个字段，却又想在子类中将这个变量的访问改变为一个计算后的值，此时就适合使用自封装字段；

【重构做法】

1. 为待封装的字段建立取值/设值函数；
2. 找出该字段的所有引用点，将它们全部改为调用取值/设值函数；
3. 将该字段封装为private；
4. 复查，确保找出所有引用点；
5. 编译测试；

【重构前范例】

```java
class IntRange {
  private int low, high;
  boolean includes(int arg) {
    return arg >= low && arg <= high;
  }
  
  void grow(int factor) {
    high = high * factor;
  }
  
  IntRage(int low, int high) {
    low = low;
    high = high;
  }
}
```

【重构后范例】

```java
/* 如果你是使用了lombok插件，那么可以直接使用它提供的@Getter/@Setter注解实现自封装 */
class IntRange {
  private int low, high;
  
  // 创建low的getter / setter方法
  public int getLow() {
    return low;
  }
  
  public void setLow(int low) {
    this.low = low;
  }
  
  // 创建high的getter / setter方法
  public int getHigh() {
    return high;
  }
  
  public void setHigh(int high) {
    this.high = high;
  }
  
  boolean includes(int arg) {
    return arg >= getLow() && arg <= getHigh();
  }
  
  void grow(int factor) {
    high = getHigh() * factor;
  }
  
  IntRage(int low, int high) {
    this.low = low;
    this.high = high;
  }
}
```

## 3.2 以对象取代数据值（Replace Data Value with Object）

【重构概要】将数据项变成对象；

【重构动机】开发初期由于业务代码复杂度不高，使用数据值进行传值操作；但是随着外部传入的数据值越来越多导致仅使用数据值无法再满足新增的需求。此时就应当把数据项抽象成一个对象；

【重构做法】

1. 为待替换数值新建一个类，在其中声明一个final字段，其类型和源类中的待替换数值类型是一样的；
2. 然后在新类中加入字段的取值函数，再加上一个接受该字段为参数的构造函数；
3. 编译；
4. 将源类中的待替换字段中的类型改为前面新建的类；
5. 修改源类中该字段的取值函数，令它们调用新类的取值函数；
6. 如果源类构造函数中用到了这个待替换字段，就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作；
7. 修改源类中待替换字段的设值函数，令它为新类创建一个实例；
8. 编译、测试；

【重构前范例】

```java
class Order {
  private String customer;
  
  public Order(String customer) {
    this.customer = customer;
  }
  
  public String getCustomer() {
    return customer;
  }
  
  public void setCustomer(String customer) {
    this.customer = customer;
  }
}

// 使用Order的范例代码可能是这样的
private static int numberOfOrdersFor(Collection orders, String customer) {
  int result = 0;
  Iterator iter = orders.iterator();
  while(iter.hasNext()) {
    Order each = (Order)iter.next();
    if (each.getCustomer().equals(customer)) {
      result ++;
    }
  }
  return result;
}
```

【重构后范例】

```java
/* 新建Customer类 */
class Customer {
  private final String name;
  
  public String getName() {
    return name;
  }
  
  public void setName(String name) {
    this.name = name;
  }
}

class Order {
  // private String customer;
  private Customer customer;
  
  public Order(String customer) {
    this.customer = new Customer(customer);
  }
  
  public String getCustomer() {
    return customer.getName();
  }
  
  public void setCustomer(String customer) {
    this.customer = new Customer(customer);
  }
}

// 使用Order的范例代码可能是这样的
private static int numberOfOrdersFor(Collection orders, String customer) {
  int result = 0;
  Iterator iter = orders.iterator();
  while(iter.hasNext()) {
    Order each = (Order)iter.next();
    if (each.getCustomer().equals(customer)) {
      result ++;
    }
  }
  return result;
}
```



## 3.3 将值对象改为引用对象（Change Value to Reference）

【重构概要】将值对象变成引用对象；

【重构动机】要在引用对象和值对象之间做出选择有时并不容易。如果你希望给一个值对象加入一些可修改的数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。就需要将该对象变成一个引用对象；

【重构做法】

1. 使用『工厂方法替换构造函数（Replace Constructor with Factory Method）』；
2. 编译、测试；
3. 决定由什么对象负责提供访问新对象的途径；
4. 决定这些引用对象应该预先创建好，或是应该动态创建；
5. 修改工厂函数，令其返回引用对象；
6. 编译、测试；

【重构前范例】

```java
/* 新建Customer类 */
class Customer {
  private final String name;
  
  public String getName() {
    return name;
  }
  
  public void setName(String name) {
    this.name = name;
  }
}

class Order {
  // private String customer;
  private Customer customer;
  
  public Order(String customer) {
    this.customer = new Customer(customer);
  }
  
  public String getCustomer() {
    return customer.getName();
  }
  
  public void setCustomer(String customer) {
    this.customer = new Customer(customer);
  }
}

// 使用Order的范例代码可能是这样的
private static int numberOfOrdersFor(Collection orders, String customer) {
  int result = 0;
  Iterator iter = orders.iterator();
  while(iter.hasNext()) {
    Order each = (Order)iter.next();
    if (each.getCustomer().equals(customer)) {
      result ++;
    }
  }
  return result;
}
```

【重构后范例】

```java
/* 新建Customer类 */
class Customer {
  private final String name;
  private static Dictionary instance = new HashTable();
  
  public static Customer getNamed(String name) {
    return (Customer)instance.get(name);
  }
  
  private Customer(String name) {
    this.name = name;
  }
  
  public String getName() {
    return name;
  }
  
  public void setName(String name) {
    this.name = name;
  }
  
  static void loadCustomers() {
    new Customer("Lemon Car Hire").store();
    new Customer("Associated Coffee Machine").store();
    new Customer("Bilson Gasworks").store();
  }
  
  private void store() {
    instance.put(this.getName(), this);
  }
}

class Order {
  // private String customer;
  private Customer customer;
  
  public Order(String customer) {
    this.customer = Customer.getNamed(customer);
  }
  
  public String getCustomer() {
    return customer.getName();
  }
  
  public void setCustomer(String customer) {
    this.customer = Customer.getNamed(customer);
  }
}

// 使用Order的范例代码可能是这样的
private static int numberOfOrdersFor(Collection orders, String customer) {
  int result = 0;
  Iterator iter = orders.iterator();
  while(iter.hasNext()) {
    Order each = (Order)iter.next();
    if (each.getCustomer().equals(customer)) {
      result ++;
    }
  }
  return result;
}
```

## 3.4 将引用对象改为值对象（Change Reference to Value）

【重构概要】将引用对象变为值对象

【重构动机】如果引用对象变得难以使用，就应该改造为值对象。引用对象必须被某种方式控制，你总是必须向其控制者请求适当的引用对象；值对象有一个非常特殊的特性。它们应该是不可变的，无论何时只要调用同一个对象的同一个查询函数。那么就应该得到一样的结果；

【重构做法】

1. 检查重构目标是否为不可变对象，或者是是否可修改的不可变对象；
2. 建立equals()和hashCode()方法；
3. 编译、测试；
4. 考虑是否可以删除工厂函数，并将构造函数声明为public；

【重构前范例】

```java
class Currency {
  private String code;
  
  public String getCode() {
    return code;
  }
  
  private Currency(String code) {
    this.code = code;
  }
  
  public static Currency get(String code) {
    return new Currency(code);
  }
}

/* 如果需要获得Currency实例需要这样使用 */
Currency usd = Currency.get("USD");
```

【重构后范例】

```java
class Currency {
  private String code;
  
  public String getCode() {
    return code;
  }
  
  private Currency(String code) {
    this.code = code;
  }
  
  public static Currency get(String code) {
    return new Currency(code);
  }
  
  /* 由于Currency是不可变的，所以实现equals方法 */
  public boolean equals(Object arg) {
    if (!(arg instanceof Currency))
      return false;
    Currency = (Currency) arg;
    return (code.equals(other.code));
  }
  
  public int hashCode() {
    return code.hashCode();
  }
}

/* 如果需要获得Currency实例需要这样使用 */
new Currecy("USD").equals(new Currency("USD"));
```

## 3.5 以对象取代数组（Replace Array with Object）

【重构概要】以对象替换数组，对于数组中的每个元素，以一个字段来表示；

【重构动机】运用字段名称和函数名称传达数组中第一个元素为人名这样子的需求能够更加清晰地提升可读性；

【重构做法】

1. 新建一个类表示数组所拥有的信息；
2. 修改数组的所有用户，让它们改用新类的实例；
3. 编译、测试；
4. 逐一为数组元素添加取值、设值函数。根据元素的用途，为这些访问函数命名；
5. 修改客户端代码，让其通过访问函数取用数组内的元素；每次修改后，编译并测试；
6. 当所有对数组的直接访问都转换成调用访问函数后，将新类中保存该数组的字段声明为private；
7. 编译；
8. 对于数组内的每一个元素，在新类中创建一个类型相当的字段。修改该元素的访问函数，令它们改用上述的新建字段；
9. 数组内的所有元素都有了对应的字段之后，删除该数组；

【重构前范例】

```java
String[] row = new String[3];
row[0] = "Liverpool";
row[1] = "15";
String name = row[0];
int wins = Integer.parseInt(row[1]);
```

【重构后范例】

```java
class Performance {
  /* 想要彻底删掉data数组可以建立name和wins变量，将Performance改造成一个值对象 */
  private String[] data = new String[3];
  
  public String getName() {
    return data[0];
  }
  
  public void setName(String name) {
    data[0] = name;
  }
  
  public Integer getWins() {
    return Integer.parseInt(data[1]);
  }
  
  public void setWins(String wins) {
    data[1] = wins;
  }
}

/* 在客户端的代码引用点将代码更改成下列样子 */
Performance row = new Performance();
row.data[0] = row.setName("Liverpool");
row.data[1] = row.setWins("15");
String name = row.getName();
int wins = row.getWins();
```

## 3.6 复制『被监视数据』（Duplicate Observed Data）

【重构概要】将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据；

【重构动机】同一份数据可能既用于领域对象，又用于GUI控件。如果你遇到的代码是以两层方式开发。业务逻辑被内嵌在用户界面中，你就有必要将行为分离出来。其中主要工作就是函数的分解和搬移。但你不能仅搬移数据而是将其复制到新对象中，并提供相应地同步机制；

【重构做法】

1. 修改现有类，使其成为领域类中Observer；
2. 针对GUI类中的领域数据，使用『自封装字段（Self Encapsulate Field）』；
3. 编译、测试；
4. 在事件处理函数中调用设值函数，直接更新GUI组件；
5. 编译、测试；
6. 在领域类中定义数据及相关访问函数；
7. 修改现有类中地访问函数，将它们地操作对象改为领域对象；
8. 修改Observer的update()，使其从相应的领域对象中将所需的数据复制给GUI组件；
9. 编译、测试；

【重构前范例】

```java
// TBC
```

【重构后范例】

```java
// TBC
```

## 3.7 将单向关联改为双向关联（Change Unidirectional Association to Bidirectional）

【重构概要】添加一个反向指针，并使修改函数能够同时更新两条连接；

【重构动机】开发初期，两个类会建立单向关联；随着重构推移会发现引用类需要得到其引用者以便进行某些处理，也就是说它需要某种反向指针；

【重构做法】

1. 在被引用类中增加一个字段，用以保存反向指针；
2. 决定由哪一个类——引用端还是被引用端——控制关联关系；
3. 在被控制端建立一个辅助函数，其命名应该清楚指出它的有限用途；
4. 如果既有的修改函数在控制端，让它负责更新反向指针；
5. 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数；

【重构前范例】

```java
class Order {
    // ...
    
    Customer getCustomer() {
        return customer;
    }
    
    void setCustomer(Customer customer) {
        this.customer = customer;
    }
    
    private Customer customer;
}
```

【重构后范例】

```java
class Order {
    // ...
    /* 因为多份Order可以被一个Customer持有，所以Order类为受控类 */
    
    Customer getCustomer() {
        return customer;
    }
    
    /* 改变修改函数，令其同时更新反向指针 */
    void setCustomer(Customer customer) {
        if (customer != null) {
            customer.friendOrders().remove(customer);
        }
        this.customer = customer;
        if (customer != null) {
            customer.friendOrders().add(customer);
        }
    }
    
    private Customer customer;
}

class Customer {
    /* 因为一个客户可以拥有多份订单，所以Customer为控制类 */
    private Set orders = new HashSet();
    
    /* 创建控制函数，使得Customer可以控制Order */
    Set friendOrders() {
        return orders;
    }
    
    /* 如果希望在Customer中修改连接，就调用其控制函数 */
    void addOrder(Order order) {
        order.setCustomer(this);
    }
}
```

## 3.8 将双向关联改为单项关联（Change Bidirectional Association to Unidirectional）

【重构概要】去掉不必要的关联；

【重构动机】双向关联虽然方便简洁，但是容易产生大量地“僵尸对象”，此时就需要解除两个类之间的双向关联关系，以此来降低系统的复杂度。所以只有在真正需要使用到双向关联的过程中才使用，否则不应该在系统中使用过多的双向关联；

【重构做法】

1. 找出保存“你想要去除指针”的字段，检查它的每一个用户，判断是否可以去除指针；
2. 如果客户使用了取值函数，先使用自封装（Self Encapsulate Field）将待删除的字段封装起来，然后使用“替换算法”干掉取值函数，令它们不再使用该字段，然后编译、测试；
3. 如果客户并未使用取值函数，直接修改待删除字段的所有被引用点；改以其他途径获得该字段所保存的对象。每次修改后，编译并测试；
4. 如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段；
5. 编译、测试；

【重构前范例】

```java
class Order {
    // ...
    
    double getDiscountedPrice() {
        return getGrossPrice() * (1 - customer.getDiscount());
    }
    
    Customer getCustomer() {
        return customer;
    }
    
    /* 改变修改函数，令其同时更新反向指针 */
    void setCustomer(Customer customer) {
        if (customer != null) {
            customer.friendOrders().remove(customer);
        }
        this.customer = customer;
        if (customer != null) {
            customer.friendOrders().add(customer);
        }
    }
    
    private Customer customer;
}

class Customer {
    /* 只有先存在Order，Customer才可以调用它，所以移除从Order到Customer的连接 */
    private Set<Order> orders = new HashSet();
    
    Set friendOrders() {
        return orders;
    }
    
    float getDiscount() {
        return 0.15;
    }
}
```

【重构后范例】

```java
class Order {
    // ...
    
    double getDiscountedPrice(Customer customer) {
        return getGrossPrice() * (1 - customer.getDiscount());
    }
    
    Customer getCustomer() {
        return customer;
    }
    
    /* 改变修改函数，令其同时更新反向指针 */
    void setCustomer(Customer customer) {
        if (customer != null) {
            customer.friendOrders().remove(customer);
        }
        this.customer = customer;
        if (customer != null) {
            customer.friendOrders().add(customer);
        }
    }
    
    private Customer customer;
}

class Customer {
    /* 只有先存在Order，Customer才可以调用它，所以移除从Order到Customer的连接 */
    private Set<Order> orders = new HashSet();
    
    Set friendOrders() {
        return orders;
    }
    
    float getDiscount() {
        return 0.15;
    }
}
```

## 3.9 以字面常量取代魔法数（Replace Magic Number with Symbolic Constant）

【重构概要】创建一个常量，根据其意义为它命名，并将上述的字面数值替换为常量；

【重构动机】『魔法数』指的是那些拥有特殊意义却不能明确表现出该意义的数字，如果在程序的不同位置使用不同的魔法数。一旦程序发生更改，你必须找到所有的魔法数并且修改它。因此将程序代码中的魔法数替换成常量有助于提高程序的可读性。

【重构做法】

1. 声明一个常量，令其为原本的魔法数值；
2. 找出这个魔法数的所有引用点；
3. 检查是否可以使用新声明的常量来代替魔法数，如果可以，则替换之；
4. 编译、测试；
5. 所有魔法数被替换完毕后，编译并测试；此时程序在改动前后的行为应当是保持一致的；

【重构前范例】

```java
double potentialEnergy(double mass, double height) {
  return * 9.81 * height;
}
```

【重构后范例】

```java
double potentialEnergy(double mass, double height) {
  return mass * GRAVITATIONAL_CONSTANT * height;
}

static final double GRAVITATIONAL_CONSTANT = 9.81;
```

## 3.10 封装字段（Encapsulate Field）

【重构概要】将类中的public字段声明为private，并提供相应的访问函数；

【重构动机】将不想暴露给其他类的成员变量『隐藏』起来，仅提供访问函数给外部；

【重构做法】

1. 为public字段提供取值/设值函数；
2. 找到这个类的之外的引用点，将原来的读值操作改为调用封装的取值函数，将原来的写值操作改为调用封装的写值函数；
3. 每次修改完后，编译并测试；
4. 修改完成后，将public改为private；

【重构前范例】

```java
class User {
  public String username;
}

// 读值操作
User user = new User();
String username = user.username;

// 写值操作
user.username = "zhangSan";
```

【重构后范例】

```java
class User {
  public String username;
  
  public String getUsername() {
    return username;
  }
  
  public void setUsername(String username) {
    this.username = username;
  }
}

// 读值操作
User user = new User();
String username = user.getUsername();

// 写值操作
user.setUsername("zhangSan");
```

## 3.11 封装集合（Encapsulate Collection）

【重构概要】如果一个函数返回一个集合，则让该函数返回一个只读副本，并在这个类中添加/删除集合元素的函数；

【重构动机】如果一个取值函数确实需要返回多个值，它应该避免用户直接按操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构；另外不应该为整个集合提供一个设置函数，但应该提供用以为集合添加/移除元素的函数。这样集合拥有者就可以控制集合元素的添加和移除；

【重构做法】

1. 加入为集合添加/移除元素的函数；
2. 将保存集合的字段初始化为一个空集合；
3. 编译；
4. 找出集合设值函数的所有调用者，你可以修改那个设值函数，让它使用上述新建的『添加/移除元素』函数；也可以直接修改调用端，改让它们调用上述新建的『添加/移除元素』的函数；
5. 编译、测试；
6. 找出所有『通过取值函数获得集合并修改其内容』的函数，逐一修改这些函数，让它们改用添加/移除函数。每次修改后，编译并测试；
7. 修改完成后，修改取值函数自身，使其返回该集合的一个只读副本；
8. 编译、测试；
9. 找出取值函数的用户，从中找出应该存在于集合所属对象内的代码，并将其移到宿主对象中去；
10. 修改现有函数的名字，然后添加一个新取值函数，使其返回一个枚举。找出旧取值函数的所有被使用点，将它们都改为使用新取值函数；
11. 编译、测试；

【重构前范例】

```java
class Course {
  public Course(String name, boolean isAdvanced) {
    //...
  }
  
  public boolean isAdvanced() {
    //...
  }
}

class Person {
  public Set getCourses() {
    return courses;
  }
  
  public void setCourses(Set courses) {
    this.courses = courses;
  }
  
  private Set courses;
}
```

【重构后范例】

```java
class Course {
  public Course(String name, boolean isAdvanced) {
    //...
  }
  
  public boolean isAdvanced() {
    //...
  }
}

class Person {
  public Set getCourses() {
    return courses;
  }
  
  /* 为Person添加新增，修改函数 */
  public void addCourse(Course course) {
    courses.add(course);
  }
  
  public void removeCourse(Course course) {
    courses.remove(course);
  }
  
  public void initializeCourses(Set courses) {
    Assert.isTrue(courses.isEmpty());
    Iterator iterator = courses.iterator();
    while(iterator.hasNext()) {
      addCourse((Course)iter.next());
    }
    this.courses = courses;
  }
  
  private Set courses;
}
```

## 3.12 以数据类取代记录（Replace Record with Class）

【重构概要】为该记录创建一个『哑』数据对象；

【重构动机】建立一个看起来类似的外部记录的类，以便日后将某些字段和函数搬移到这个类之中。一个不太常见但非常令人注目的情况是：数组中的每个位置上的元素都有特定含义，这种情况下应该是用『使用对象替换数组』

【重构做法】

1. 新建一个类，表示这个记录；
2. 对于记录中的每一项数据，在新的类中建立对应的private字段，并提供相应地取值/设值函数；
3. 得到一个哑巴对象之后，再根据过程中进一步解决这个问题；

## 3.13 以类取代类型码（Replace Type Code with Class）

【重构概要】以一个新的类替换该数值的类型码；

【重构动机】使用一个有意义的符号名可以提升代码的可读性和理解性，但是类型码对应编译器来说只能看到数值，这样反而会降低代码的可读性，从而成为bug之源。但是如果将类型数值换成一个类，编译器就可以对这个类的类型进行校验。只要这个类提供了工厂函数，就可以始终保证只有合法的实例才可以被创建出来；

【重构做法】

1. 为类型码建立一个类；
2. 修改源类实现，让它使用上述新建的类；
3. 编译、测试；
4. 对于源类中的每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类；
5. 逐一修改源类用户，让它们使用新接口；
6. 每修改一个用户，编译并测试；
7. 删除使用类型码的旧接口，并删除保存旧类型码的静态变量；
8. 编译、测试；

【重构前范例】

```java
class Person {
  public static final int O = 0;
  public static final int A = 1;
  public static final int B = 2;
  public static final int AB = 3;
  
  public Person(int bloodGroup) {
    this.bloodGroup = bloodGroup;
  }
  
  public int getBloodGroup() {
    return bloodGroup;
  }
  
  public void setBloodGroup(int bloodGroup) {
    this.bloodGroup = bloodGroup;
  }
  
  private int bloodGroup;
}
```

【重构后范例】

```java
class Person {
  public static final int O = BloodGroup.O.getCode();
  public static final int A = BloodGroup.A.getCode();
  public static final int B = BloodGroup.B.getCode();
  public static final int AB = BloodGroup.AB.getCode();
  
  public Person(BloodGroup bloodGroup) {
    this.bloodGroup = bloodGroup;
  }
  
  public int getBloodGroup() {
    return bloodGroup.getCode();
  }
  
  public void setBloodGroup(BloodGroup bloodGroup) {
    this.bloodGroup = bloodGroup;
  }
  
  private BloodGroup bloodGroup;
}

class BloodGroup {
  public static final BloodGroup O = new BloodGroup(0);
  public static final BloodGroup A = new BloodGroup(1);
  public static final BloodGroup B = new BloodGroup(2);
  public static final BloodGroup AB = new BloodGroup(3);
  
  private static final BloodGroup[] values = {O, A, B, AB};
  private final int code;
  
  private BloodGroup(int code) {
    this.code = code;
  }
  
  public int getCode() {
    return code;
  }
  
  public static BloodGroup code(int arg) {
    return values[arg];
  }
}
```

## 3.14 以子类取代类型码（Replace Type Code with Subclasses）

【重构概要】以子类取代这个类型码；

【重构动机】如果面对的类型码不会影响宿主类的行为，可以用『子类取代类型码』；如果类型码会影响宿主类的行为，那么最好的办法就是借助多态来处理变化的行为；为建立这样的继承体系，最简单的办法就是以类型码的宿主类作为基类，针对每种类型码建立相应的子类；

【重构做法】

1. 使用『自封装（Slef Encapsulate Field）』将类型码自我封装起来；
2. 为类型码的每一个数值建立一个相应的子类，再每个子类中覆写类型码的取值函数，使其返回相应的类型码值；
3. 每建立一个新的子类，编译并测试；
4. 从超类中删掉保存类型码的字段，将类型码访问函数声明为抽象函数；
5. 编译、测试；

【重构前范例】

```java
class Employee {
  private int type;
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  Employee(int type) {
    this.type = type;
  }
}
```

【重构后范例】

```java
class Employee {
  private int type;
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  Employee(int type) {
    this.type = type;
  }
  
  int getType() {
    return type;
  }
  
  /* 最后create函数就变成了这样子 */
  static Employee create(int type) {
    switch (type) {
      case ENGINEER:
        return new Engineer();
      case SALESMAN:
        return new Salesman();
      case MANAGER:
        return new Manager();
      default:
        throw new IlleganArgumentException("Incorrect type code value");
    }
  }
}

class Engineer extends Employee {
  int getType() {
    return Employee.ENGINEER;
  }
}

class Salesman extends Employee {
  int getType() {
    return Employee.SALESMAN;
  }
}

class Manager extends Employee {
  int getType() {
    return Employee.MANAGER;
  }
}
```

## 3.15 以State/Strategy取代类型码（Replace Type Code with State/Strategy）

【重构概要】以状态对象取代类型码；

【重构动机】如果类型码的值在声明周期内发生变化，除了使用3.14的重构手法外，也可以使用本重构手法；使用策略模式和状态模式的过程类似。但是到底是使用策略模式还是使用状态模式则需要根据业务场景来判断；

【重构过程】

1. 使用『自封装（Self Encapsulate Field）』将类型码自我封装起来；
2. 新建一个类，根据类型码的用途为期命名，称之为一个状态对象；
3. 为这个新类添加子类，每个子类对应一种类型码；
4. 在超类中建立一个抽象的查询函数，用以返回类型码。在每一个子类中覆写该函数，返回确切的类型码；
5. 编译；
6. 在源类中建立一个字段，用以保存信件的状态对象；
7. 调整源类中负责查询类型码的函数，将查询动作转发给状态对象；
8. 调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给『保存状态对象』的那个字段；
9. 编译、测试；

【重构前范例】

```java
class Employee {
  private int type;
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  Employee(int type) {
    this.type = type;
  }
  
  int payAmount() {
    switch(type) {
      case ENGINEER:
        return monthlySalary;
      case SALESMAN:
        return monthlySalary + commission;
      case MANAGER:
        return monthlySalary + bonus;
      default:
        throw new RuntimeException("Incorrect Employee");
    }
  }
}
```

【重构后范例】

```java
class Employee {
  private EmployeeType type;
  
  int getType() {
    return type.getTypeCode();
  }
  
  void setType(int type) {
    this.type = EmployeeType.newType(type);
  } 
  
  int payAmount() {
    switch(getType()) {
      case EmployeeType.ENGINEER:
        return monthlySalary;
      case EmployeeType.SALESMAN:
        return monthlySalary + commission;
      case EmployeeType.MANAGER:
        return monthlySalary + bonus;
      default:
        throw new RuntimeException("Incorrect Employee");
    }
  }
}

abstract class EmployeeType {
  abstract int getTypeCode();
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  static EmployeeType newType(int code) {
    switch (code) {
      case ENGINEER:
        return new Engineer();
      case SALESMAN:
        return new Salesman();
      case MANAGER:
        return new Manager();
      default:
        throw new IllegalArgumentException("Incorrect Employee Code");
    }
  }
}

class Engineer extends EmployeeType {
  int getTypeCode() { return Employee.ENGINEER; }
}

class Salesman extends EmployeeType {
  int getTypeCode() { return Employee.SALESMAN; }
}

clss Manager extends EmployeeType {
  int getTypeCode() { return Employee.MANAGER; }
}
```

## 3.16 以字段取代子类（Replace Subclass with Fields）

【重构概要】修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类；

【重构动机】建立子类的目的，是为了增加新特性或变化其行为。尽管常量函数有其用途，但若子类中只有常量函数（返回一个硬编码的值的函数）实在是没有足够的存在价值，因此我们可以在超类中设置一个与常量函数返回值相同的字段，从而完全去除这样的子类。如此一来就可以避免因继承儿带来额外的复杂性；

【重构做法】

1. 对所有子类使用『使用工厂方法替换构造函数（Replace Constructor with Factory Method）』;
2. 如果有任何代码直接引用子类，令它改而引用超类；
3. 针对每个常量函数，在超类中声明一个final字段；
4. 新建或修改子类构造函数，使它调用超类的新增构造函数；
5. 编译、测试；
6. 在超类中实现所有常量函数，令它们返回相应字段值，然后将该函数从子类中删除；
7. 每删除一个常量函数，编译并测试；
8. 子类中的所有常量函数都被删除后，使用『内联方法（Inline Method）』将子类构造函数内联到超类的工厂方法中；

【重构前范例】

```java
abstract class Person {
  abstract boolean isMale();
}

class Male extends Person {
  boolean isMale() {
    return true;
  }
  
  char getCode() {
    return 'M';
  }
}

class Fenale extends Person {
  boolean isMale() {
    return false;
  }
  
  char getCode() {
    return 'F';
  }
}
```

【重构后范例】

```java
abstract class Person {
  private final boolean isMale;
  private final char code;
  
  protected Person(boolean isMale, char code) {
    this.isMale = isMale;
    this.code = code;
  }
  
  abstract boolean isMale();
  
  static Person createMale() {
    return new Male();
  }
  
  static Person createFemale() {
    return new Female();
  }
}

class Male extends Person {
  public Male() {
    super(true, 'M');
  }
}

class Fenale extends Person {
  public Female() {
    super(false, 'F');
  }
}
```



# 4 简化条件表达式

## 4.1 分解条件表达式（Decompose Conditional）

【重构概要】从if、then和else三个段落中分别提炼出独立函数；

【重构动机】复杂的逻辑语句是最常见的复杂度上升点之一，你必须编写代码检查不同的条件分支、根据不同的分支做不同的事情。然后就会很容易得到一个相当长的函数，从而使得可读性下降。因此最好的方式就是将这些if语句代码拆解成不同的小段函数，每个分解函数的名称根据拆解的用途命名。从而更加清晰地表达清楚代码的意图。

【重构做法】

1. 将if段落提炼出来，构成一个独立函数；
2. 将then段落和else段落都提炼出来，各自构成一个独立函数；
3. 如果发现嵌套语句逻辑，通常会先观察是否可以使用『Replace Nested Conditional with Guard Clause』，如果不行，再开始拆解其中的每个条件；

【重构前范例】

```java
if (date.before(SUMMER_START) || date.after(SUMMER_END)) {
  charge = quantity * winterRate + winterServiceCharge;
} else {
  charge = quantity * summerRate;
}
```

【重构后范例】

```java
if (notSummer(date)) {
  charge = winterCharge(quantity);
} else {
  charge = summerCharge(quantity);
}

private boolean notSummer(Date date) {
  return date.before(SUMMER_START) || date.after(SUMMER_END);
}

private double summerCharge(int quantity) {
  return quantity * summerRate;
}

private double winterCharge(int quantity) {
  return quantity * winterRate + winterServiceCharge;
}
```



## 4.2 合并条件表达式（Consolidate Conditional Expression）

【重构概要】将条件测试集合合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数；

【重构动机】有时候代码中存在这样的条件检查语句：检查条件各不相同，最终行为却一致。如果发现这种情况就应该使用『逻辑或』和『逻辑与』，将它们合并为一个条件表达式；合并的目的是想告诉读者，实际上只有一次条件检查，只不过有多个并列条件需要检查而已。因此条件检查合并的目的一定是不互相独立的。

【重构做法】

1. 确定这些条件语句都没有副作用；
2. 使用适当的逻辑操作符，将一系列相关条件表达式合并为一个；
3. 编译、测试；
4. 对合并后的条件表达式实施『提炼方法（Extract Method）』；

【重构前范例】

```java
double disabilityAmount() {
  if (seniority < 2) return 0;
  if (monthsDisabled > 12) return 0;
  if (isPartTime) return 0;
  // 计算disability amount
}
```

【重构后范例】

```java
double disabilityAmount() {
  if (isNotEligibleForDisability()) return 0;
  // 计算disability amount
}

double boolean isNotEligibleForDisability() {
  return (seniority < 2) || (monthsDisabled > 12) || (isPartTime);
}
```

## 4.3 合并重复的条件片段（Consolidate Duplicate Conditional Fragments）

【重构概要】将这段重复代码搬移到条件表达式之外；

【重构动机】有时候一组条件表达式的所有分支都执行了相同的某段逻辑，如果是这样子。就应该将这段代码搬移到条件表达式外面。这样代码才能更清楚地表明哪些东西随条件的变化而变化、哪些东西保持不变；

【重构做法】

1. 鉴别『执行方式不随条件变化而变化』的代码；
2. 如果这些共通代码位于条件表达式的起始处，就将它移到条件表达式之前；
3. 如果这些共通代码位于条件表达式的尾端，就将它们移到条件表达式之后；
4. 如果这些共通代码位于条件表达式的中段，就需要观察共通代码之前或之后的代码是否改变了什么东西。如果确实有所改变，应该首先将共通代码向前或向后移动，移至条件表达式的起始处或尾端，再以前面所有的办法来处理；
5. 如果共通代码不止一条语句，应该首先使用『提炼方法（Extract Method）』将共通代码提炼到一个独立函数中，再以前面所说的办法来处理；

【重构前范例】

```java
if (isSpecialDeal()) {
  total = price * 0.5;
  send();
} else {
  total = price * 0.98;
  send();
}
```

【重构后范例】

```java
if (isSpecialDeal()) {
  total = price * 0.5;
} else {
  total = price * 0.98;
}
send();
```

## 4.4 移除控制标记（Remove Control Flag）

【重构概要】以break语句或return语句取代控制标记；

【重构动机】使用break语句或者continue语句来跳出复杂的条件语句好过使用控制标记。去掉控制标记产生的效果往往会让你大吃一惊，条件语句真正的用途会清晰很多；

【重构做法】

1. 对控制标记的处理，最显而易见的办法是使用Java提供的break语句或者continue语句；

2. 找出让你跳出这段逻辑的控制标记值；

3. 找出对标记变量赋值的语句，代以恰当的break语句或者continue语句；

4. 每次替换后，编译并测试；

5. 在未能提供break和continue语句的编程语言中可以使用下述方法：

   5.1 运用『提炼方法（Extract Method）』将整段逻辑提炼到一个独立函数中；

   5.2 找出让你跳出这段逻辑的控制标记值；

   5.3 找出对标记变量赋值的语句，代以恰当的return语句；

   5.4 每次替换后，编译并测试；

6. 即便是编程语言提供break和continue语句的情况下，我也坚持使用重构5中的步骤，因为return语句可以清晰的表示不再执行该函数中其他段的代码；

【重构前范例】 -- 使用return返回控制标记

```java
void checkSecurity(String[] people) {
  String found = "";
  for (int i = 0; i < people.length(); i++) {
    if (found.equals("")) {
      if (people[i].equals("Don")) {
        sendAlert();
        found = "Don";
      }
      if (people[i].equals("John")) {
        sendAlert();
        found = "John";
      }
    }
  }
  someLaterCode(found);
} 
```

【重构后范例】

```java
void checkSecurity(String[] people) {
  String found = "";
  found = foundMiscreant(people);
  someLaterCode(found);
}

String foundMiscreant(String[] people) {
  String found = "";
  for (int i = 0; i < people.length; i++) {
    if (found.equals("")) {
      if (people[i].equals("Don")) {
        sendAlert();
        return "Don";
      }
      if (people.equals("John")) {
        sendAlert();
        return "John";
      }
    }
  }
  return found;
}
```

## 4.5 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）

【重构概要】使用卫语句表现所有特殊情况；

【重构动机】如果在判断逻辑中发现有某个if的条件极其罕见，应该单独做检查，再直接返回结果。这样的if语句称之为『卫语句』；在程序中有时候更多的是if-then-else的形式。因此本重构的精髓就是：如果你对if-else的分支重视程度是一样的，那么这样的代码结构传递给同读者的信息就是：各个分支都有同样的重要性，卫语句就不同了，它告诉读者：『这种情况很罕见，如果它真的发生了，请务必做一些整理工作，然后退出』；

【重构做法】

1. 对于每一个检查，放进一个卫语句；
2. 每次将条件检查替换成卫语句后，编译并测试；

【重构前范例】

```java
double getPayAmount() {
  double result;
  if (isDead) result = deadAmount();
  else {
    if (isSeparated) result = separatedAmount();
    else {
      if (isRetried) result = retiredAmount();
      else result = normalPayAmount();
    }
  }
  return result;
}
```

【重构后范例】

```java
double getPayAmount() {
  if (isDead) {
    return deadAmount();
  }
  if (isSeparated) {
    return separatedAmount();
  }
  if (isRetired) {
    return reitredAmount();
  }
  return normalPayAmount();
}
```

## 4.6 以多态取代条件表达式（Replace Conditional with Polymorphism）

【重构概要】将switch类型的表达式的每一个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数；

【重构动机】多态最根本的好处就在于：如果你需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显不同的表达式，正因为多态使用，才使得在面向对象程序中很少出现if-then-else或者swtich语句的行为；因此如果程序能够使用多态的时候则应当多使用多态；

【重构做法】

1. 首先你必须拥有一个继承结构，如果没有，那么你必须先建立它；
2. 建立子类的手法可以参考『用子类替换子类』或者『使用State/Strategy代替类型码』两种形式，依照具体情况自行选择；
3. 拥有继承结构后，找到需要重构的代码，可能是if-else结构，可能是switch结构；
4. 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数，将与该子类相关的条件表达式分支复制到新建函数中，并对它进行适当调整；
5. 编译、测试；
6. 在超类中删掉条件表达式内被复制的分支；
7. 编译、测试；
8. 针对条件表达式的每个分支重复4~7步骤，直到所有分支都被移到子类内的函数为止；
9. 将超类之中容纳条件表达式的函数声明卫抽象函数；

【重构前范例】

```java
class Employee {
  private EmployeeType type;
  
  int getType() {
    return type.getTypeCode();
  }
  
  void setType(int type) {
    this.type = EmployeeType.newType(type);
  } 
  
  int payAmount() {
    switch(getType()) {
      case EmployeeType.ENGINEER:
        return monthlySalary;
      case EmployeeType.SALESMAN:
        return monthlySalary + commission;
      case EmployeeType.MANAGER:
        return monthlySalary + bonus;
      default:
        throw new RuntimeException("Incorrect Employee");
    }
  }
}

abstract class EmployeeType {
  abstract int getTypeCode();
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  static EmployeeType newType(int code) {
    switch (code) {
      case ENGINEER:
        return new Engineer();
      case SALESMAN:
        return new Salesman();
      case MANAGER:
        return new Manager();
      default:
        throw new IllegalArgumentException("Incorrect Employee Code");
    }
  }
}

class Engineer extends EmployeeType {
  int getTypeCode() { return Employee.ENGINEER; }
}

class Salesman extends EmployeeType {
  int getTypeCode() { return Employee.SALESMAN; }
}

clss Manager extends EmployeeType {
  int getTypeCode() { return Employee.MANAGER; }
}
```

【重构后范例】

```java
class Employee {
  private EmployeeType type;
  
  int getType() {
    return type.getTypeCode();
  }
  
  void setType(int type) {
    this.type = EmployeeType.newType(type);
  } 
  
  int payAmount() {
    return this.payAmount(this);
  }
  
  abstract int payAmount(Employee employee);
}

abstract class EmployeeType {
  abstract int getTypeCode();
  static final int ENGINEER = 0;
  static final int SALESMAN = 1;
  static final int MANAGER = 2;
  
  static EmployeeType newType(int code) {
    switch (code) {
      case ENGINEER:
        return new Engineer();
      case SALESMAN:
        return new Salesman();
      case MANAGER:
        return new Manager();
      default:
        throw new IllegalArgumentException("Incorrect Employee Code");
    }
  }
}

class Engineer extends EmployeeType {
  int getTypeCode() { return Employee.ENGINEER; }
  
  int payAmount(Employee employee) {
    return employee.getMonthlySalary();
  }
}

class Salesman extends EmployeeType {
  int getTypeCode() { return Employee.SALESMAN; }
  
  int payAmount(Employee employee) {
    return employee.getMonthlySalary() + employee.getCommission();
  }
}

clss Manager extends EmployeeType {
  int getTypeCode() { return Employee.MANAGER; }
  
  int payAmount(Employee employee) {
    return employee.getMonthlySalary() + employee.getBonus();
  }
}
```

## 4.7 引入Null对象（Introduce Null Object）

【重构概要】将null值替换成null对象；

【重构动机】多态的好处在于：你不必再向对象询问『你是什么类型』而后根据得到答案调用对象的某个行为——你只管调用行为就是了。其他的一切多态机制都会为你安排妥当。当某个字段内容是null的时候，多态可扮演一个比较不直观的角色。

【重构做法】

1. 为源类建立一个子类，使其行为就像使源类的null版本，在源类和null子类中都加上isNull函数，前者的isNull()应该是返回false，后者的isNull()应该使返回true；
2. 编译；
3. 找出所有『索求源对象却获得一个null』的地方，修改这些地方，使它们改而获得一个空对象；
4. 找出所有『将源对象与null做比较』的地方，修改这些地方，使它们调用isNull()函数；
5. 编译、测试；
6. 找出这样的程序点：如果对象不是null，做A动作，否则做B动作；
7. 对于上述每一个地点，在null类中覆写A动作，使其行为和B动作相同；

【重构前范例】

```java
class Site {
  Customer getCustomer() {
    return customer;
  }
  
  private Customer customer;
}

class Customer {
  public String getName() {/* TODO: getName */}
  public BillingPlan getPlan() {/* TODO: getPlan */}
  public PaymentHistory getHistory() {/* TODO: getHistory */}
}

class PaymentHistory {
  int getWeeksDelinquentInLastYear() {/* TODO: getWeeksDelinquentInLastYear*/}
}

// 示例片段
Customer customer = site.getCustomer();
BillingPlan plan;
if (customer == null) {
  plan = BillingPlan.basic();
} else {
  plan = customer.getPlan();
}
// ...
String customerName;
if (customer == null) {
  customerName = "occupant";
} else {
  customerName = customer.getName();
}
// ...
int weeksDelinquent;
if (customer == null) {
  weeksDelinquent = customer.getHistory().getWeeksDelinquentInLastYear();
}
```

【重构后范例】

```java
class Site {
  Customer getCustomer() {
    return customer == null ? Customer.newNull() : customer;
  }
  
  private Customer customer;
}

class Customer {
  public String getName() {/* TODO: getName */}
  public BillingPlan getPlan() {/* TODO: getPlan */}
  public PaymentHistory getHistory() {/* TODO: getHistory */}
  
  public boolean isNull() {
    return false;
  }
  
  //也可以使用工厂函数
  static Customer newNull() {
    return new NullCustomer();
  }
  
  protected Customer() {}
}

// 新建NullCustomer空对象
class NullCustomer extends Customer {
  public boolean isNull() {
    return true;
  }
  
  public String getName() {
    return "occupant";
  }
  
  public PaymentHistory getHistory() {
    return PaymentHistory.newNull();
  }
}

//你也可以这样定义
interface Nullable {
  boolean isNull();
}

class Customer implements Nullable {
  boolean isNull() {
    return false;
  }
}

class PaymentHistory {
  int getWeeksDelinquentInLastYear() {/* TODO: getWeeksDelinquentInLastYear*/}
  
  static PaymentHistory newNull() {
    return new PaymentHistory();
  }
}

class NullPaymentHistory extends PaymentHistory {
  int getWeeksDelinquentInLastYear() {
    return 0;
  }
}

// 示例片段
Customer customer = site.getCustomer();
BillingPlan plan;
if (customer.isNull()) {
  plan = BillingPlan.basic();
} else {
  plan = customer.getPlan();
}
// ...
String customerName;
if (customer.isNull()) {
  customerName = customer.getName();
} else {
  customerName = customer.getName();
}
// ...
int weeksDelinquent;
if (customer.isNull()) {
  weeksDelinquent = customer.getPaymentHistory();
}
```

## 4.8 引入断言（Introduce Assertion）

【重构概要】以断言明确表现这种假设；

【重构动机】程序中尝尝存在这样的代码：只有当某个条件为真时，该段代码才能继续运行下去。这样的假设通常没有在代码中明确表现出来，必须要阅读整个算法才能看出。有时候会在程序中使用注释来说明此种假设。但是使用断言能够更好的说明代码的意图：因此从交流的角度上，断言能够帮助程序阅读者理解代码中所做的假设；

【重构做法】

1. 如果程序员不犯错，断言就应该不会对系统运行造成任何影响，所以加入断言永远不会影响程序的运行；
2. 如果发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况；
3. 注意：不要滥用断言：请不要使用断言来检查『认为应该为真』，而是『一定必须为真』的条件，滥用断言容易造成难以维护的逻辑；
4. 所以：时常询问自己：如果断言所指示的约束条件不能满足，代码是否仍然能正常运行，如果可以，就去掉断言；
5. 最后还需要注意去掉断言中的重复代码，它们和其他任何地方的重复代码一样不好闻，所以请大胆地使用Extract Method将其去除；

【重构前范例】

```java
class Employee {
  private static final double NULL_EXPENSE = -1.0;
  private double expenseLimit = NULL_EXPENSE;
  private Project primaryProject;
  
  double getExpenseLimit() {
    return expenseLimit != NULL_EXPENSE ? expenseLimit : primaryProject.getMemberExpenseLimit();
  }
  
  boolean withinLimit(double expenseAmount) {
    return (expenseAmount <= getExpenseLimit());
  }
}
```

【重构后范例】

```java
class Employee {
  private static final double NULL_EXPENSE = -1.0;
  private double expenseLimit = NULL_EXPENSE;
  private Project primaryProject;
  
  double getExpenseLimit() {
    // 大胆地假设：任何员工要么参与某个项目，要么有个人开支限额
    // 阻止断言一定被执行一遍的重构方式
    if (Assert.ON) {
      Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != null); 
    }
    return expenseLimit != NULL_EXPENSE ? expenseLimit : primaryProject.getMemberExpenseLimit();
  }
  
  boolean withinLimit(double expenseAmount) {
    return (expenseAmount <= getExpenseLimit());
  }
}
```

# 5 简化函数调用

## 5.1 函数改名（Rename Method）

【重构概要】修改函数名称

【重构动机】给函数起一个好名称。函数名称应该准确表达它的用途，给函数重命名的一个好办法，首先考虑应该给这个函数写一个什么样的注释，然后想办法将注释的内容提炼成函数名称；如果你的函数名称起的不好，那么就无法准确表明函数的真正意图，从而影响代码的阅读性；

【重构做法】

1. 检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤

   1.1 声明一个新函数，将它命名为你想要的新名称。将旧函数中的逻辑拷贝到新函数中，并进行适当的调整；

   1.2 编译，修改旧函数，令它将调用转发给新函数；

   1.3 编译、测试；

   1.4 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数。每次修改后，编译并测试；

   1.5 删除旧函数，或者是使用Deprecated注解将此函数标记为『已废弃』；

【重构前范例】

```java
public String getTelephoneNumber() {
  return "(" + officeAreaCode + ")" + officeNumber;
}

// 我想把这个函数的名称重命名为getOfficeTelephoneNumber
```

【重构后范例】

```java
@Deprecated
public String getTelephoneNumber() {
  return "(" + officeAreaCode + ")" + officeNumber;
}

public String getOfficeTelephoneNumber() {
  return "(" + officeAreaCode + ")" + officeNumber;
}
```

## 5.2 添加参数（Add Parameter）

【重构概要】为此函数添加一个对象参数，让该对象带进函数所需信息；

【重构动机】你必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此需要给函数添加一个参数；但是这里要注意不使用这个重构的动机：检查你现有函数的参数列表，除了添加参数外是否能找到更好地重构手法，如果可以，那么不建议使用本项重构手法。

【重构做法】

1. 检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤；
2. 声明一个新函数，名称与原函数相同，只是加上新添参数。将旧函数的代码复制到新函数中；
3. 编译、修改旧函数，令它调用新函数；
4. 编译、测试；

## 5.3 移除参数（Remove Parameter）

【重构概要】函数本身不需要某个参数，将该参数去除；

【重构动机】一个程序员在开发中打的如意算盘是：无论如何，多余的参数都不会引起任何问题，而且以后还有可能会使用到。但是这其实是错误的。函数调用者必须为每一个参数操心该传什么东西进去。如果不去掉多余的参数，就是让每一个用户多费一份心。是很不划算的。更何况『去除参数』这么简单的一种重构手法；

【重构做法】

1. 检查函数签名是否被超类或子类实现过，如果是则需要针对每份实现分别进行下列步骤：
2. 声明一个新函数，名称与原函数相同，只是去除不必要的参数。将旧函数的代码复制到新函数中；
3. 编译、修改旧函数，令它们调用新函数；
4. 编译、测试；
5. 找出旧函数的所有被引用点，将它们全部修改为对新函数的引用。每次修改后，编译并测试；
6. 删除旧函数；
7. 编译并测试，由于此重构过于简单，可一次性删除多个多余参数；

## 5.4 将查询函数和修改函数分离（Separate Query from Modifier）

【重构概要】某个函数既返回对象状态，又修改对象状态。建立两个不同的函数，其中一个负责查询，另一个负责修改；

【重构动机】任何有返回值的函数，都不应该有看得到的副作用（只返回值不做别的就代表没有『副作用』），因此如果发现一个函数『既有返回值又有副作用』，那么就应该将查询动作从修改动作中分割出来。『看得到的副作用』，有一种常见的优化方法：将查询所得的结果置于某个字段中，这样一来后续的重复查询就可以大大加快速度。虽然这种方式改变不了对象状态，但是这样的修改一般对于外界是查询不到的。

> 此重构手法在并发系统中属于惯用重构手法，注意学习！！！

【重构做法】

1. 新建一个查询函数，令它们返回的值与原函数相同；

   > 观察原函数，看看它返回的是什么东西。如果返回的是一个临时变量，找出临时变量的位置；

2. 修改原函数，令它们调用查询函数，并返回获得的结果；

3. 编译、测试；

4. 将调用原函数的代码改为调用查询函数，然后在调用查询函数的那一行之前，加上对原函数的调用，每次修改后，编译并测试；

5. 将原函数的返回值改为void，并删掉其中所有的return语句；

【重构前范例】

```java
// 典型的『副作用』函数
String foundMiscreant(String[] people) {
  for (int i = 0; i < people.length; i++) {
    if (people[i].equals("Don")) {
      sendAlert();
      return "Don";
    }
    if (people[i].equals("John")) {
      sendAlert();
      return "John";
    }
  }
  return "";
}

void checkSecurity(String[] people) {
  String found = foundMiscreant(people);
  someLaterCode(found);
}
```

【重构后范例】

```java
void sendAlert(String[] people) {
  if (!foundPerson(people).equals("")) {
    sendAlert();
  }
}

void checkSecurity(String[] people) {
  sendAlert(people);
  String found = foundPerson(people);
  someLaterCode(found);
}

String foundPerson(String[] people) {
  for (int i = 0; i < people.length; i++) {
    if (people[i].equals("Don")) {
      return "Don";
    }
    if (people[i].equals("John")) {
      return "John";
    }
  }
  return "";
}
```

## 5.5 令函数携带参数（Parameterize Method）

【重构概要】建立单一函数，以参数表达那些不同的值；

【重构动机】两个函数做着类似的工作，但因少数几个值致使行为略有不同，此时应该将这些各自分离的函数统一起来，并通过函数参数来处理变化。此时应该首先将这些代码抽到一个独立函数中，然后再对提炼所得的函数使用本重构；

【重构做法】

1. 新建一个带有参数的函数，使它可以替换先前所有的重复性函数；
2. 编译；
3. 将调用旧函数的代码改为调用新函数；
4. 编译、测试；
5. 对所有旧函数重复上述步骤，每次替换后，修改并测试；

【重构前范例】

```java
class Employee {
  void tenPercentRate() {
    salary *= 1.1;
  }
  void fivePercentRaise() {
    salary *= 1.05;
  }
}
```

【重构后范例】

```java
class Employee {
  void tenPercentRate() {
    salary *= raise(0.1);
  }
  void fivePercentRaise() {
    salary *= raise(0.05);
  }
  
  // 替换成这个算法
  void raise(double factor) {
    salary *= (1 + factor);
  }
}
```

## 5.6 以明确函数取代参数（Replace Parameter with Explicit Methods）

【重构概要】有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立函数；

【重构动机】如果某个参数有多种可能的值，而函数又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应当使用本重构手法；

【重构做法】

1. 针对参数的每一种可能值，新建一个明确函数；
2. 修改条件表达式的每个分支，使其调用合适的新函数；
3. 修改每个分支后，编译并测试；
4. 修改原函数的每个被调用点，改而调用上述的某个合适的新函数；
5. 编译、测试；
6. 所有调用端都修改完毕后，删除原函数；

【重构范例】

```java
class Employee {
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    
    // 将switch分支中的函数替换成新建的参数函数
    static Employee create(int type) {
        switch(type) {
            case ENGINEER:
                // return new Engineer();
                return Employee.createEngineer();
            case SALESMAN:
                // return new Salesman();
                return Employee.createSalesman();
            case MANAGER:
                // return new Manager();
                return Employee.createManager();
            default:
                throw new IllegalArgumentException("Incorrect type code value");
        }
    }
    
    // 根据参数先建立相应的工厂函数
    static Employee createEngineer() {
        return new Engineer();
    }
    
    static Employee createSalesman() {
        return new Salesman();
    }
    
    static Employee createManager() {
        return new Manager();
    }
}
```

## 5.7 保持对象完整（Preserve Whole Object）

【重构概要】从某个对象取出若干值，将它们作为某一次函数调用时的参数，改为传递整个对象；

【重构动机】有时候会将一个对象的若干数据项作为参数传递给某个函数，但是当需要将新增的数据项作为参数传递时，你就必须查找并修改对此函数的所有调用；如果你把数据项所属的对象作为参数传递给参数，就可以避免这种尴尬的境地。除此之外，把数据对象作为函数参数传递可以提高代码的可读性。不过事情总是具备两面性，这意味着当你为了引用数据对象中的某些数据项时会不可避免地将不需要使用的其他数据项一起引入到其他函数中，这样反而会使得依赖结构发生恶化，此时你就不应该继续此重构；

【重构做法】

1. 对你的目标函数新增一个数据项，用以代表原数据所在的完整对象；
2. 编译、测试；
3. 判断哪些参数可被包含在新增的完整对象中；
4. 选择上述参数之一，将被调用函数中原来引用该参数的地方，改为调用新增参数对象的相应取值函数；
5. 删除该项参数；
6. 测试、编译；
7. 针对所有可以从完整对象中获得的参数，重复前述步骤；
8. 删除调用端中那些带有被删除参数的代码；
9. 编译、测试；

【重构前范例】

```java
class Room {
    boolean withinPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withRange(low, high);
    }
    
    class HeatingPlan {
        boolean withinRange(int low, int high) {
            return (low >= range.getLow() && high <= range.getHigh());
        }
        
       private TempRange range;
    }
}
```

【重构后范例】

```java
class Room {
    boolean withPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withRange(daysTempRange(), low, high);
    }
    
    class HeatingPlan {
        boolean withRange(TempRange range) {
            return (low >= range.getLow() && high <= range.getHigh());
        }
    }
}
```

## 5.8 以函数取代参数（Replace Parameter with Methods）

【重构概要】对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也可以调用前一个函数，让参数接受者去除该项参数，并直接调用前一个函数；

【重构动机】如果函数可以通过其他途径获得参数值，那么就不应该通过参数取得值，而应该直接转而调用函数本身。过长的参数列表会增加代码阅读的难度。因此我们应当尽可能地缩短参数列表的长度；

【重构做法】

1. 如果有必要，将参数的计算过程提炼到一个独立函数中；
2. 将函数本体内的引用该参数的地方改为调用新建的函数；
3. 每次替换后，修改并测试；
4. 全部替换完成后，移除参数；

【重构前范例】

```java
public double getPrice() {
  int basePrice = quantity * itemPrice;
  int discountLevel;
  if (quantity > 100) {
    discountLevel = 2;
  } else {
    discountLevel = 1;
  }
  double finalPrice = discountedPrice(basePrice, discountLevel);
  return finalPrice;
}

private double discountedPrice(int basePrice, int discountLevel) {
  if (discountLevel == 2) {
    return basePrice * 0.1;
  }
  return basePrice * 0.05;
}
```

【重构后范例】

```java
public double getPrice() {
  int basePrice = quantity * itemPrice;
  double finalPrice = discountedPrice(basePrice);
  return finalPrice;
}

public int getDiscountLevel() {
  if (quantity > 100) {
    return 2;
  }
  return 1;
}

private double discountedPrice(int basePrice) {
  if (getDiscountLevel() == 2) {
    return basePrice * 0.1;
  }
  return basePrice * 0.05;
}
```

## 5.9 引入参数对象（Introduce Parameter Object）

【重构概要】某些参数总是很自然地同时出现，以一个对象取代这些参数；

【重构动机】常常会看到特定地一组参数总是一起传递，可能有好几个函数都使用这一组参数，这些函数同属一个类。这样一组参数就是所谓的『数据泥团』。我们可以使用一个对象包装所有这些数据，再以该对象取代它们；哪怕只是为了把这些数据组织在一起，这样做也是十分值得的；

【重构做法】

1. 新建一个类，用以表现你想替换地一组参数，将这个类设置为不可变的；
2. 编译；
3. 针对使用该组参数的所有函数，实施『添加参数』，传入上述新建类的实例对象，并将此参数设置为null；
4. 对于『数据泥团』中的每一项从函数签名中去除，并修改调用端和函数本体；
5. 每去除一个参数，编译并测试；
6. 去除原先所有的参数后，观察是否有无适当函数可以使用『搬移方法』搬移到参数对象之中；

【重构前范例】

```java
class Entry {
  Entry(double value, Date chargeDate) {
    this.value = value;
    this.chargeDate = chargeDate;
  }
  
  Date getDate() {
    return chargeDate;
  }
  
  double getValue() {
    return value;
  }
  
  private Date chargeDate;
  private double value;
}

class Account {
  double getFlowBetween(Date start, Date end) {
    double result = 0;
    Enumeration e = entries.elements();
    while(e.hasMoreElements()) {
      Entry each = (Entry)e.nextElement();
      if (each.getDate().equals(start) || each.getDate().equals(end) ||
         each.getDate().after(start) && each.getDate().before(end)) {
        result += each.getValue();
      }
    }
    return result;
  }
  private Vector entries = new Vector();
}

// client code
double flow = anAccount.getFlowBetween(startDate, endDate);
```

【重构后范例】

```java
// 创建DateRange类，表示时间范围
class DateRange {
  DateRange(Date start, Date end) {
    this.start = start;
    this.end = end;
  }
  
  Date getStart() {
    return start;
  }
  
  Date getEnd() {
    return end;
  }
  
  boolean includes(Date arg) {
    return (arg.equals(start)||
           arg.equals(end)||
           (arg.after(start) && arg.before(end)));
  }
  
  private final Date start;
  private final Date end;
}

class Entry {
  Entry(double value, Date chargeDate) {
    this.value = value;
    this.chargeDate = chargeDate;
  }
  
  Date getDate() {
    return chargeDate;
  }
  
  double getValue() {
    return value;
  }
  
  private Date chargeDate;
  private double value;
}

class Account {
  double getFlowBetween(Date start, Date end) {
    double result = 0;
    Enumeration e = entries.elements();
    while(e.hasMoreElements()) {
      Entry each = (Entry)e.nextElement();
      if (range.includes(each.getDate())) {
        result += each.getValue();
      }
    }
    return result;
  }
  private Vector entries = new Vector();
}

// client code
double flow = anAccount.getFlowBetween(new DateRange(startDate, endDate));
```

## 5.10 移除设值参数（Remove Setting Method）

【重构概要】类中的某个字段应该在对象创建是被设值，然后就不再改变；去掉该字段的所有设值函数；

【重构动机】如果你为某个字段设置了设值函数，则说明这个值可以被改变，如果你不希望字段在对象创建后还能被改变，那么就不要为它提供设值函数（同时将该字段设置为final），这样你的意图会更加清晰；

【重构做法】

1. 检查设值函数被使用的情况，看它是否只被构造函数调用，或者被构造函数所调用的另一个函数调用；
2. 修改构造函数，使其直接访问设值函数所针对的那个变量；
3. 编译、测试；
4. 移除这个设值函数，将它所针对的字段设为final；
5. 编译、测试；

【重构前范例】

```java
class Account {
  private String id;
  
  Account(String id) {
    this.id = id;
  }
  
  void setId(String id) {
    this.id = id;
  }
  
  String getId() {
    return id;
  }
}
```

【重构后范例】

```java
class Account {
  private final String id;
  
  Account(String id) {
    this.id = "ZZ" + id;
  }
  
  String getId() {
    return id;
  }
}
```

## 5.11 隐藏函数（Hide Method）

【重构概要】如果一个函数从没有被任何类使用到，就将其访问权限设置为private；

【重构动机】一种常见的情况是：当你面对一个只有简单封装的数据容器时，随着越来越多的行为被加入到这个类中，你会发现有一些函数不需要再公开，因此可以将它们隐藏起来，然后再所有地方都直接访问变量，那么就可以放心移除取值/设值函数；

【重构做法】

1. 经常检查有没有可能降低某个函数的可见度；
2. 尽可能降低所有函数的可见度；
3. 每完成一组函数隐藏后，编译并测试；

## 5.12 用工厂函数取代构造函数（Replace Constructor with Factory Method）

【重构概要】你希望创建对象的过程中不是简单地建构动作，将构造函数替换成工厂函数；

【重构动机】常见的动机是：在派生子类的过程中使用类型码，你可能常常需要根据类型码来创建相应地对象；

【重构做法】

1. 新建一个工厂函数，让它调用现有构造函数；
2. 将调用构造函数的代码改为调用工厂函数；
3. 每次替换后，编译并测试；
4. 将构造函数声明为private；
5. 编译；

【重构前范例】

```java
class Employee {
    private int type;
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    
    Employee(int type) {
        this.type = type;
    }
}
```

【重构后范例】

```java
// Sample 1
class Employee {
    private int type;
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    
    Employee(int type) {
        this.type = type;
    }
    
    /* 希望Employee能提供不同的子类 */
    static Employee create(int type) {
        return new Employee(type);
    }
}

// Sample 2
class Employee {
    private int type;
    static final int ENGINEER = 0;
    static final int SALESMAN = 1;
    static final int MANAGER = 2;
    
    static Employee create(int type) {
        switch(type) {
            case ENGINEER:
                // 使用新写的create函数创建子类，
                return Employee.create("Engineer");
            case SALESMAN:
                return Employee.create("Salesman");
            case MANAGER:
                return Employee.create("Manager");
            default:
                throw new IllegalArgumentException("Incorrect type code value");
        }
    }
    
    // 使用反射创建子类，也是工厂方法实现的一种思路
    static Employee create(String name) {
        try {
            return (Employee)Class.forName(name).newInstance();
        } catch(Exception e) {
            throw new IllegalArgumentException("Unable to instanitate " + name);
        }
    }
}
```

## 5.13 封装向下转型（Encapsulate Downcast）

【重构概要】某个函数返回对象，需要由函数调用者执行向下转型，将向下转型的动作移到函数中；

【重构动机】如果某一个函数返回一个值，并且知道所返回的对象类型比翻书签名所昭告的跟特化，便是函数在用户身上强加了非必要的工作，这个时候你不应该要求用户承担向下转型的责任；

【重构做法】

1. 找出必须对函数调用结果进行向下转型的地方；
2. 将向下转型的动作搬移到该函数中；

【重构范例】

```java
// 如果初始函数是长这样
Object lastReading() {
    return readings.lastElement();
}

// 那我现在的函数应该修改成这样
Reading lastReading() {
    return (Reading)readings.lastReading();
}
```

## 5.14 用异常取代错误码（Replace Error Code with Exception）

【重构概要】某个函数返回一个特定的代码，用以表示某种错误情况，改用异常；

【重构动机】当一段程序发生错误，它需要让它的调用者知道错误，而调用者也可能将这个错误依照调用链传递上去。使用异常的方式能够清楚地将“普通程序”和“错误处理”区分开来。这样的程序更加容易理解；

【重构做法】

1. 决定应该抛出“受控异常”还是“非受控异常”；
2. 找到该函数的调用者，对它们进行相应的调用调整，让它们调用异常；
3. 修改该函数的名称，令它们反映新用法；
4. 如果函数有许多调用者，那么上述修改的跨度可能稍微大一点；

【重构范例】

```java
  class Account {
      int withdraw(int amount) {
          if (amount > balance) {
              return -1;
          } else {
              balance -= amount;
              return 0;
          }
      }
      
      private int balance;
  }

// 非受控异常
if (account.withdraw(amount) == 1) {
    handleOverdrawn();
} else {
    account.withdraw(amount);
    doTheUsualCode();
}
```



## 5.15 用测试取代异常（Replace Exception with Test）

# 6 处理概括关系

## 6.1 字段上移（Pull up Field）

## 6.2 函数上移（Pull up Method）

## 6.3 构造函数本体上移（Pull up Constructor Body）

## 6.4 函数下移（Push down Method）

## 6.5 字段下移（Push down Field）

## 6.6 提炼子类（Extract Subclass）

## 6.7 提炼超类（Extract Superclass）

## 6.8 提炼接口（Extract Interface）

## 6.9 折叠继承体系（Collapse Hierarchy）

## 6.10 塑造模板函数（Form Template Method）

## 6.11 以委托取代继承（Replace Inheritance with Delegation）

## 6.12 以继承取代委托（Replace Delegation with Inheritance）

# 7 大型重构

## 7.1 梳理并分解继承体系（Tease Apart Inheritance）

## 7.2 将过程化设计转化为对象设计（Convert Procedural Design to Objects）

## 7.3 将领域和表述/显示分离（Separate Domain from Presentation）

## 7.4 提炼继承体系（Extract Hierarchy）
