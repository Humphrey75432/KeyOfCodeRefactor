# 描述重构手法的一种草案格式

## 重构名称

**【重构概要】** 简要介绍重构手法的适用场景以及所能在实际环境中解决的问题;

**【重构动机】** 需要使用该重构来完成代码整理的动机以及时机，如有确定的一些特征也可以罗列在下方;

**【重构做法】** 说明重构执行的每个具体步骤。格式如下：

1. 重构的第一个步骤；
2. 重构的第二个步骤；

**【重构前范例】** 使用一段示例代码展示重构前的代码结构以及存在的问题;

```java
public class BeforeRefactor {
    public void beforeMethod() {
        // ... 重构之前的代码结构
    }
}
```

**【重构后范例】** 使用一段示例代码展示重构后的代码结构以及实现的效果;

```java
public class AfterRefactor {
    public void afterMethod() {
        // ...重构之后的代码结构
    }
}
```

------

# 1 重新组织函数

## 1.1 提炼函数（Extract Method）

**【重构概要】** 将一段代码放进一个独立函数，并让函数名称解释函数的用途；

**【重构动机】** 一个过长的函数或者需要一段注释才能让人理解用途的代码，使用一个独立函数来解释代码的用途；

**【重构做法】**

1. 提取需要抽到新函数中的代码片段；
2. 将提取出来的代码片段放入新函数中；
3. 删除步骤1的代码片段，替换成步骤2中的新函数；
4. 运行并测试，验证重构后是否保持一样的行为；

**【重构前范例】**

```java
public class RefactorClass {
    public void printOwing(String name, double amount) {
        printBanner();
        /* 提取以下两行代码并抽至新函数printAmount中 */
        System.out.println("name: " + name);
        System.out.println("amount: " + amount);
    }
}
```

**【重构后范例】**

```java
public class RefactorClass {
    public void printOwing(String name, double amount) {
        printBanner();
        /* 注释原有的两行代码，改调用新函数，查看效果 */
        // System.out.println("name: " + name);
        // System.out.println("amount: " + amount);
        printAmount(String name, double amount);
    }
    
    /* 创建新函数printAmount */
    private void printAmount(String name, double amount) {
        System.out.println("name: " + name);
        System.out.println("amount: " + amount);
    }
}
```

## 1.2 内联函数（Inline Method）

**【重构概要】** 一个函数本体与其名称同样清楚易懂，在函数调用点插入函数本体并移除函数本身；

**【重构动机】** 在函数的内部代码与函数名称同样清晰易读的情况下，应当直接用函数本体，而不是使用一个短小函数对其做过度包装；

**【重构做法】**

1. 检查需要修改的函数，确定其不具备多态性；
2. 找出该函数的所有被调用点并将其调用点替换为函数本体；
3. 编译以及测试，确定不造成副作用后移除旧代码；

**【重构前范例】**

```java
public class RefactorClass{
    public int getRatings() {
        /* 检查待修改函数，找到调用点 */
        return (moreThanFiveLateDeliveries()) ? 2 : 1;
    }
    
    private boolean moreThanFiveLateDeliveries() {
        /* 函数本体和函数名称一样清晰可懂 */
        return numberOfLateDeliveries > 5;
    }
}
```

**【重构后范例】**

```java
public class RefactorClass {
    public int getRatings() {
        /* 替换函数调用点为函数本体 */
        return numberOfLateDeliveries > 5;
        /* 移除旧调用点，编译测试 */ 
        // return (moreThanFiveLateDeliveries()) ? 2 : 1;
    }
}
```

## 1.3 内联临时变量（Inline Temporary Variable）

**【重构概要】** 将所有对该变量的引用动作，替换成对它赋值的那个表达式本身

**【重构动机】** 当某个临时变量被赋予某个函数调用的返回值，如果它的存在会妨碍其他重构手法时，就应当对其进行重构；

**【重构做法】**

1. 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用；
2. 如果该临时变量未被声明为final，就将其声明为final，然后编译；
3. 找到该临时变量的所有引用点，将其替换成“为临时变量”赋值的表达式；
4. 修改完成后编译、测试、并删除该临时变量的声明和赋值语句；

**【重构前范例】**

```java
/* 函数本体和函数名称一样简单易懂 */
double basePrice = anOrder.basePrice();
return (basePrice > 1000);
```

**【重构后范例】**

```java
/* 替换函数名称为函数本体中的内容 */
return (anOrder.basePrice() > 1000);
```

## 1.4 以查询取代临时变量（Replace Temporary with Query）

**【重构概要】** 将临时变量保存德表达式提炼到一个独立函数中，将这个临时变量德所有引用点替换为新函数德调用。此后，新函数就可以被其他函数所使用。

**【重构动机】** 临时变量只在所属函数内使用，因此对外来说是不可见的。为了使得其他函数能够见到同属的一份信息，可以将临时变量替换为一个查询。

**【重构做法】**

1. 找出只被赋值一次的临时变量，将其声明为final进行编译；
2. 将『对该临时变量赋值』的语句登号右侧部分提炼到一个独立函数；

**【重构前范例】**

```java
double basePrice = quantity * itemPrice;
if (basePrice > 1000) {
  return basePrice * 0.95;
} else {
  return basePrice * 0.98;
}
```

**【重构后范例】**

```java
if (basePrice > 1000) {
  basePrice() * 0.95;
} else {
  basePrice() * 0.98;
}

double basePrice() {
  return quantity * itemPrice;
}
```

## 1.5 引入解释性变量（Introduce Explaining Variable）

**【重构概要】** 将复杂表达式（或其中的一部分）的结果放进一个临时变量，以此变量名称来解释表达式的用途；

**【重构动机】** 表达式可能非常复杂难以阅读，临时变量可以帮助表达式分级为比较容易管理和理解的形式；

**【重构做法】**

1. 声明一个final变量，将待分解的复杂表达式中的一部分动作的运算结果赋值给他；
2. 将表达式中的『运算结果』中的一部分替换为上述的临时变量；
3. 编译，测试并重复上述步骤；

**【重构前范例】**

```java
if (platform.toUpperCase().indexOf("MAC") > -1 &&
   platform.toUpperCase().indexOf("IE") > -1 &&
   wasInitialized() $$ resize > 0) {
  // do something
}
```

**【重构后范例】**

```java
final boolean isMacOS = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = platform.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize > 0;
if (isMacOS && isIEBrowser && wasInitialized() && wasResized) {
  // do something
}
```

## 1.6 分解临时变量（Split Temporary Variable）

**【重构概要】** 针对每一次赋值，创建一个独立、对应的临时变量；

**【重构动机】** 某些对临时变量的用途有可能导致临时变量被多次赋值，例如循环变量会随着循环的每次进行而改变；结果收集变量会将整个函数的运算构成某个数值后再收集起来。多次被赋值的临时变量承担了多重责任，就应当被替换分解诚多个临时变量，每个变量值承担一个责任；

**【重构做法】**

1. 在待分解临时变量的声明以及第一次被赋值处修改其名称，并将新的临时变量声明为final；
2. 以该临时变量的第二次赋值动作为界限，修改此前对该临时变量的所有引用点，让它们引用新的临时变量；
3. 编译、测试并重复前述步骤；

**【重构前范例】**

```java
/* 临时变量第一次被创建以及赋值的地方，此时temp表示周长 */
double temp = 2 * (height + width);
System.out.println(temp);
/* 临时变量第二次被赋值的地方，此时temp表示面积 */
temp = height * width;
System.out.println(temp);
```

**【重构后范例】**

```java
/* 将第一次赋值的地方命名为perimeter，并用final修饰 */
final double perimeter = 2 * (height + width);
System.out.println(perimeter);
/* 将临时变量第二次赋值的地方命名为area，并用final修饰 */
final double area = height * width;
System.out.println(area);
/* 后续如有类似的代码使用同样的方法进行修改 */
```

## 1.7 移除对参数的赋值（Remove Assignments to Parameters）

**【重构概要】** 用一个临时变量取代该参数的位置；

**【重构动机】** 如果代码的语义是按引用传递的，就在调用端检查调用后是否使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。尽量使用一个return来返回一个值。如果返回值比较多，可以将返回的数据封装成一个对象，或者干脆为每一个返回值设置一个独立函数；

**【重构做法】**

1. 建立一个临时变量，把待处理的参数值赋予它；
2. 以『对参数赋值』为界，将其后所有对此参数的引用点，全部替换成『对此临时变量』的引用；
3. 修改赋值语句，使其改为对新建的临时变量赋值；

**【重构前范例】**

```java
int discount(int putVal, int quantity, int yearToDate) {
  if (putVal > 50) putVal -= 2;
}
```

**【重构后范例】**

```java
int discount(int putVal, int quantity, int yearToDate) {
  int result = inputVal;
  if (result > 50) result -= 2;
}
```

## 1.8 以函数对象取代函数（Replace Method with Method Object）

**【重构概要】** 将这个函数放进一个单独对象中，局部变量变成对象内的字段。这样就可以再同一个对象中将大型函数分解成诸多个小型函数；

**【重构动机】** 局部变量会增加函数分解的难度，通常情况下会使用Replace Temporary with Query消除局部变量。一旦该方法失效，就应当使用对象来取代函数。该方法的核心是将所有的局部变量都变成函数的对象字段。然后在抽取的对象中使用Extract Method创造出新函数。从而将原本的大型函数拆解成短小函数；

**【重构做法】**

1. 建立一个新类，根据待处理函数的用途，为这个类命名；
2. 在新类中建立一个final字段，用以保存原先大型函数所在的对象，该对象称之为『源对象』，同时针对原函数的每个临时变量和每个参数，在新类中建立一个对应字段保存；
3. 在新类中建立构造函数，接收源对象以及原函数的所有参数作为参数；
4. 在新类中建立一个compute函数，并将原函数中的代码赋值到compute函数中，如果需要调用源对象中的任何函数，可以通过源对象字段调用；
5. 编译；

**【重构前范例】**

```java
class Account {
  int gamma(int inputVal, int quantity, int yearToDate) {
    int importantValue1 = (inputVal * quantity) + delta();
    int importantValue2 = (inputVal * yearToDate) + 100;
    if (yearToDate - importantValue1 > 100) {
      importantValue2 -= 20;
    }
    int importantValue3 = importantValue2 * 70;
    return importantValue3 - 2 * imporantValue1;
  }
}
```

**【重构后范例】**

```java
class Account {
  int gamma(int intputVal, int quantity, int yearToDate) {
    return new Gamma(this, inputVal, quantity, yearToDate).compute();
  }
}

/* 创建新类 */
class Gamma {
  /* 创建源对象 */
  private final Account account;
  private final int inputVal;
  private final int quantity;
  private final int yeatToDate;
  
  /* 创建原函数中的临时变量字段 */ 
  private final int importantValue1;
  private final int importantValue2;
  private final int importantValue3;
  
  /* 创建构造函数，接受源对象以及源对象字段 */
  public Gamma(Account account, int inputValue, int quantity, int yearToDate) {
    this.account = account;
    this.inputVal = inputVal;
    this.quantity = quantity;
    this.yearToDate = yearToDate;
  }
  
  /* 创建compute方法，搬移原函数中的相应逻辑 */ 
  public int compute() {
    int importantValue1 = (intputVal * quantity) + delta();
    int importantValue2 = (intputVal * yearToDate) + 100;
    /* 调用拆解出来的新函数 */
    importantThing()
    int importantValue3 = importantValue2 * 7;
    return importantValue3 - 2 * importantValue1;
  }
  
  /* 使用Extract Method对compute函数做拆解 */
  void importantThing() {
    if ((yearToDate - importantValue1) > 100) {
      importantValue2 -= 20;
    }
  }
}
```

## 1.9 替换算法（Substitute Algorithm）

**【重构概要】** 将函数本体替换成另外一种算法

**【重构动机】** 如果做一件事情可以有更加清晰的方式，就应该使用更清晰的方式代替复杂的方式。替换的前提需要把复杂的大代码块替换成简单的小块，再进行替换；

**【重构做法】**

1. 准备替换用的算法；
2. 针对现有测试，执行上述新算法，如果重构后的结果与原本相同，重构结束；
3. 如果测试结果不同于原先，在测试和调试的过程中，以旧算法作为比较参照标准；

**【重构前范例】**

```java
String foundPerson(String[] people) {
  for (int i = 0; i < people.length; i++) {
    if (people[i].equals("Don")) {
      return "Don";
    }
    if (people[i].equals("John")) {
      return "John";
    }
    if (people[i].equals("Kent")) {
      return "Kent";
    }
  }
  return "";
}
```

**【重构后范例】**

```java
String foundPerson(String[] people) {
  List candidates = Arrays.asList(new String[]{"Don", "John", "Kent"});
  for (int i = 0; i < people.length; i++) {
    if (candidates.contains(people[i])) {
      return people[i];
    }
  }
  return "";
}
```

# 2 在对象之间搬移特性

## 2.1 搬移函数（Move Method）
**【重构概要】** 在该函数最常引用的类中建立一个有着类似行为的新函数，并将旧函数变成一个单纯地委托函数，或者是完全移除旧函数；

**【重构动机】** 一个类有太多行为或者两个类之间高度耦合，就需要尝试搬移函数。需要搬移的函数一般具备这样的特点：使用另一个对象的次数比使用自己所驻对象的次数还多。那么这种类型的函数就是可移动的。并且观察这个函数与哪边的交流比较多，救尝试把它搬移到哪边；

**【重构做法】**

1. 检查源类中被源函数所使用的一切特性（包括字段和函数），考虑其是否应该被搬移；
2. 检查源类的子类和超类，看看是否还有该函数的其他声明；
3. 在目标中使用新函数；
4. 将源函数的代码复制到目标函数中并调用后者，使其在新家中能够正常运行；
5. 编译目标类，并决定如何从源函数正确引用目标对象；
6. 修改源函数，使之成为一个纯委托函数；
7. 编译、测试；
8. 决定是否删除源函数，或将它变成一个委托函数保留下来；
9. 如果要删除函数，将源类中对源函数的所有调用替换成对目标函数的调用；
10. 编译、测试；

**【重构前范例】**

```java
class Account {
    /* 现在有多个Account，每个Account都有属于自己的"透支金额计费规则" */
    /* 决定将overdraftCharge方法迁移到AccountType类中 */
    double overdraftCharge() {
        if (type.isPremium()) {
            double result = 10;
            if (daysOverdraft > 7) {
                result += (daysOverdraft - 7) * 0.85;
                return result;
            }
            retuen daysOverdraft * 1.75;
        }
    }
    
    double bankCharge() {
        double result = 4.5;
        if (daysOverdraft > 0) {
            result += overdraftCharge;
        }
        return result;
    }
    private AccountType type;
    private int overdraftCharge;
}
```

**【重构后范例】**

```java
class AccountType {
    /* 将原属于Account中的函数搬移到AccountType中 */
	double overdraftCharge(int daysOverdrawn) {
		if (isPremium()) {
			double result = 10;
			if (daysOverdrawn > 7) {
				result += (daysOverdrawn - 7) * 0.85;
				return result;
			}
		}
		return daysOverdrawn * 1.75;
	}
}

class Account {
	double bankCharge() {
        /* 将源函数的本体替换成另一个函数的简单委托 */
		return type.overdraftCharge(daysOverdrawn)
	}
	AccountType type;
	private int daysOverdrawn;
}
```

## 2.2 搬移字段（Move Field）
**【重构概要】** 在目标新类中建立一个字段，修改源字段的所有用户，令它们改用新字段；

**【重构动机】** 对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就需要考虑搬移该字段，所谓的“使用”可能是通过设置/取值函数间接进行的；

**【重构做法】**

1. 如果字段访问级别是public，使用封装字段（Encapsulate Field）将其封装起来，并编译测试；
2. 在目标类中建立源字段相同的字段，并同时建立相应的设置/取值函数；
3. 编译目标类，决定如何在源对象中引用目标对象；
4. 删除源字段，将所有对源字段的引用替换成对某个目标函数的调用；
5. 将所有对源字段的引用替换成对某个目标函数的调用；
6. 编译、测试；

**【重构前范例】**

```java
class Account {
    private AccountType type;
    /* 将interestRate搬移到AccountType类中 */
    private double interestRate;
    
    double interestForAmountDays(double amount, int days) {
        return interestRate * amount * days / 365;
    }
}
```

**【重构后范例】**

```java
class Account {
    private AccountType type;
    /* 将interestRate搬移到AccountType类中 */
    @Deprecated
    private double interestRate;
    
    double interestForAmountDays(double amount, int days) {
        /* 先用自封装的getter方法替换待迁移的变量 */
        // return getInterestRate() * amount * days / 365;
        return type.getInterestRate() * amount * days / 365;
    }
    
    /* 自我封装 */
    /* 自封装方法可以在所有搬移字段都迁移完毕后直接删除 */
    @Deprecated
    void setInterestRate(double interestRate) {
        this.interestRate = interestRate;
    }
    
    @Deprecated
    double getInterestRate() {
        return interestRate;
    }
}

class AccountType {
    /* 将待搬移的字段抽到新类中 */
	private double interestRate;
	
    /* 对新类中的字段做自封装 */
	public void setInterestRate(double interestRate) {
		this.interestRate = interestRate;
	}

	public double getInterestRate() {
		return interestRate;
	}
}
```

## 2.3 提炼类（Extract Class）
**【重构概要】** 建立一个新类，将相关的字段和函数从旧类搬移到新类；

**【重构动机】** 一个类应当是一个清楚的抽象，处理一些明确的职责。但随着职责的不断增加，类会变得越来越复杂。这种含有大量函数和数据的类往往是非常不容易理解的。此时你就需要考虑将哪些职责搬移出去，哪些职责保留在本类中。一个有用的测试就是询问自己：如果你搬移了某个函数和字段，会发生什么事情。

**【重构做法】**

1. 决定分解类所负的职责；
2. 建立一个新类，用以表现从旧类中分离出来的责任；
3. 建立“从旧类访问新类”的连接关系；
4. 对于你想搬移的每一个字段使用“搬移字段（Move Field）”方法；
5. 每次搬移后，编译、测试；
6. 使用Move Method将必要函数搬移到新类，先搬移较低层次的函数，再搬移较高层次的函数；
7. 每次搬移之后，编译、测试；
8. 检查每个类的接口；
9. 决定是否公开新类，如果明确公开，就决定让其成为引用对象还是不可变对象；

**【重构前范例】**

```java
class Person {
    private String name;
    private String officeAreaCode;
    private String officeNumber;

    public String getName() {
        return name;
    }
    
    /* 准备将电话号码的行为抽到一个独立的类中 */
    public String getTelephoneNumber() {
        return "(" + officeAreaCode + ")" + officeNumber;
    }

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

**【重构后范例】**

```java
class Person {
    private String name;
    // private String officeAreaCode;
    // private String officeNumber;
    private TelephoneNumber officeTelephoneNumber = new TelephoneNumber();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTelephoneNumber() {
        return "(" + officeTelephoneNumber.getOfficeAreaCode() + ")" + officeTelephoneNumber.getOfficeNumber();
    }
}

/* 创建一个新类TelephoneNumber */
class TelephoneNumber {
    /* 抽取officeAreaCode和officeNumber */ 
    private String officeAreaCode;
    private String officeNumber;

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

## 2.4 将类内联化（Inline Class）

【重构概要】 将这个类的所有特性搬移到另一个类中，然后移除原类；

【重构动机】如果一个类正好不再承担足够的责任、不再有单独存在的理由（通常是此前的重构动作搬走了这个类的责任），就会挑这个“萎缩类”的最频繁用户；将其塞入用户类中；

【重构做法】

1. 在目标类身上生命源类的public协议，并将其中所有函数委托至源类；
2. 修改所有源类引用点，改用引用目标类；
3. 编译、测试；
4. 使用Move Method和Move Field将源类的特性全部搬移到目标类；
5. 为源类举行一个“简单的丧礼”；

【重构前范例】

```java
class Person {
    private String name;
    // private String officeAreaCode;
    // private String officeNumber;
    private TelephoneNumber officeTelephoneNumber = new TelephoneNumber();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTelephoneNumber() {
        return "(" + officeTelephoneNumber.getOfficeAreaCode() + ")" + officeTelephoneNumber.getOfficeNumber();
    }
}

/* TelephoneNumber这个类和Person类是分离开的 */
class TelephoneNumber {
    /* 抽取officeAreaCode和officeNumber */ 
    private String officeAreaCode;
    private String officeNumber;

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

【重构后范例】

```java
class Person {
    private String name;
    private String officeAreaCode;
    private String officeNumber;

    public String getName() {
        return name;
    }
    
    /* 准备将电话号码的行为抽到一个独立的类中 */
    public String getTelephoneNumber() {
        return "(" + officeAreaCode + ")" + officeNumber;
    }

    public String getOfficeAreaCode() {
        return officeAreaCode;
    }

    public void setOfficeAreaCode(String officeAreaCode) {
        this.officeAreaCode = officeAreaCode;
    }

    public String getOfficeNumber() {
        return officeNumber;
    }

    public void setOfficeNumber(String officeNumber) {
        this.officeNumber = officeNumber;
    }
}
```

## 2.5 隐藏『委托』关系（Hide Delegate）

【重构概要】 在服务类上建立客户所需的所有函数，用以隐藏委托关系；

【重构动机】 如果某个客户先通过服务对象得到另一个对象，然后调用后者的函数，那么客户就必须知道这一层的委托关系。万一委托关系发生变化，客户也需要做出相应的变化；此时就需要将委托关系隐藏起来，以此去除这种依赖关系。如此一来即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及用户；

【重构做法】

1. 对于每一个委托关系中的函数，在服务对象端创建一个简单的委托函数；
2. 调整客户，令它只调用服务对象提供的函数；
3. 每次调整后，编译并测试；
4. 如果将来不再有任何客户需要使用委托类，直接移除服务对象中相关的访问函数；
5. 编译、测试；

【重构前范例】

```java
class Person {
  Department department;
  
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 假使客户John想要知道Manager是谁，必须先要知道对应的Department */
manager = john.getDepartment().getManager();
```

【重构后范例】

```java
class Person {
  Department department;
  
  /* 只要Person中不再使用这个函数，就可以将其从Person中删除 */
  @Deprecated
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  /* 建立Department类中的委托函数 */
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 改用Person的所有用户，改用新函数 */
manager = john.getManager();
```

## 2.6 移除中间人（Remove Middle Man）

【重构概要】 让客户直接调用受托类；

【重构动机】 使用“隐藏委托（Hide Delegate）”可以帮助我们将不必要的委托隐藏起来，但是其副作用也是十分明显的。每当客户要使用受托类的新特性时，必须要相应地在服务端添加一个简单委托函数。随着受托类的功能越来越多，服务类完全变成一个“中间人”，此时应该直接让客户调用受托类；

【重构做法】

1. 建立一个函数，用以获得受托对象；
2. 对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象；
3. 处理每个委托函数后，编译、测试；

【重构前范例】

```java
class Person {
  Department department;
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 为了找出John的经理，现在代码实现是这样的 */
manager = john.getManager();
```

【重构后范例】

```java
class Person {
  Department department;
  
  /* 创建getDepartment委托函数 */
  public Department getDepartment() {
    return department;
  }
  
  public void setDepartment(Department department) {
    this.department = department;
  }
  
  /* 去除getManager的受托函数 */
  public Person getManager() {
    return department.getManager();
  }
}

class Department {
  private String chargeCode;
  private Person manager;
  
  public Department(Person manager) {
    this.manager = manager;
  }
  
  public Person getManager() {
    return manager;
  }
}

/* 为了找出John的经理，现在可以通过调用getDepartment方法得到Manager */
manager = john.getDepartment().getManager();
```

## 2.7 引入外加函数（Introduce Foreign Method）

【重构概要】 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例；

【重构动机】 为本不属于待修改的服务类中添加需要提供的职责，超出服务类本身职责的函数称之为外加函数。外加函数必须保证通用性，如果在系统中有多处调用，则要考虑将外加函数做成公共模块；

【重构做法】

1. 在客户类中建立一个函数，用来提供你需要的功能；
2. 以服务类实例作为该函数的第一个参数；
3. 将该函数注释为“外加函数，应在服务类中实现”；

【重构前范例】

```java
/* 将赋值运算符的右侧提炼到独立函数nextDay中 */
Date newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() + 1);
```

【重构后范例】

```java
Date newStart = nextDay(previousEnd);
private static Date nextDay(Date arg) {
    new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() + 1);
}
```

## 2.8 引入本地扩展（Introduce Local Extension）

【重构概要】 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类；

【重构动机】 类的作者无法预知未来，如果需要额外的函数超过两个，外加函数则无法控制这种变化。因此需要将这些函数组织到一起，放到一个恰到的地方。这个时候就需要使用本地扩展（子类化或包装）；

【重构做法】

1. 建立一个扩展类，将它作为原始类的子类或包装类；

2. 在扩展类中加入**转型构造函数**；

   > 转型构造函数：接受原对象作为参数的构造函数，如果是用子类化方法，转型构造函数应该调用适当的超类构造函数；如果使用包装方法，那么转型构造函数应当将它得到的传入参数以实例变量的形式保存起来，用作接受委托的原对象；

3. 在扩展类中加入新特性；

4. 根据需要将原对象替换为扩展对象；

5. 将针对原始类定义的所有外加函数搬移到扩展类中；

【重构前范例】

```java
// 以扩展JDK中的Date类为例 -- JDK8以下的特性
```

【重构后范例】

```java
/* 使用子类方式扩展 */
class MfDateSub extends Date {
    public MfDateSub nextDay() {...}
    public int dayOfYear() {...}
    
    /* 创建构造转型函数 */
    public MfDateSub(Date arg) {
        super(arg.getTime());
    }
    
    public MfDateSub(String dateString) {
        super(dateString);
    }
    
    /* 在扩展类中添加新特性 */
    private static Date nextDay(Date arg) {
        return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
    }
}

/* 使用包装方式扩展 */
class MfDateWrap {
    private Date original;
    
    public MfDateWrap(String dateString) {
        original = new Date(dateString);
    }
    
    /* 创建转型构造函数 */    
    public MfDateWrap(Date arg) {
        original = arg;
    }
    
    public ine getYear() {
        return original.getYear();
    }
    
    public boolean equals(Object arg) {
        if (this == arg) {
            return true;
        }
        if (!(arg.instanceof(MrDateWrap))) {
            return false;
        }
        MfDateWrap other = ((MfDateWrap)arg);
        return (original.equals(other.original));
    }
}
```

# 3 重新组织数据

## 3.1 自封装字段（Self Encapsulate Field）

## 3.2 以对象取代数据值（Replace Data Value with Object）

## 3.3 将值对象改为引用对象（Change Value to Reference）

## 3.4 将引用对象改为值对象（Change Reference to Value）

## 3.5 以对象取代数组（Replace Array with Object）

## 3.6 复制『被监视数据』（Duplicate Observed Data）

## 3.7 将单向关联改为双向关联（Change Unidirectional Association to Bidirectional）

## 3.8 将双向关联改为单项关联（Change Bidirectional Association to Unidirectional）

## 3.9 以字面常量取代魔法数（Replace Magic Number with Symbolic Constant）

## 3.10 封装字段（Encapsulate Field）

## 3.11 封装集合（Encapsulate Collection）

## 3.12 以数据类取代记录（Replace Record with Class）

## 3.13 以类取代类型码（Replace Type Code with Class）

## 3.14 以子类取代类型码（Replace Type Code with Subclasses）

## 3.15 以State/Strategy取代类型码（Replace Type Code with State/Strategy）

## 3.16 以字段取代子类（Replace Subclass with Fields）

# 4 简化条件表达式

## 4.1 分解条件表达式（Decompose Conditional）

## 4.2 合并条件表达式（Consolidate Conditional Expression）

## 4.3 合并重复的条件片段（Consolidate Duplicate Conditional Fragments）

## 4.4 移除控制标记（Remove Control Flag）

## 4.5 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）

## 4.6 以多态取代条件表达式（Replace Conditional with Polymorphism）

## 4.7 引入Null对象（Introduce Null Object）

## 4.8 引入断言（Introduce Assertion）

# 5 简化函数调用

## 5.1 函数改名（Rename Method）

## 5.2 添加参数（Add Parameter）

## 5.3 移除参数（Remove Parameter）

## 5.4 将查询函数和修改函数分离（Separate Query from Modifier）

## 5.5 令函数携带参数（Parameterize Method）

## 5.6 以明确函数取代参数（Replace Parameter with Explicit Methods）

## 5.7 保持对象完整（Preserve Whole Object）

## 5.8 以函数取代参数（Replace Parameter with Methods）

## 5.9 引入参数对象（Introduce Parameter Object）

## 5.10 移除设值参数（Remove Setting Method）

## 5.11 隐藏函数（Hide Method）

## 5.12 用工厂函数取代构造函数（Replace Constructor with Factory Method）

## 5.13 封装向下转型（Encapsulate Downcast）

## 5.14 用异常取代错误码（Replace Error Code with Exception）

## 5.15 用测试取代异常（Replace Exception with Test）

# 6 处理概括关系

## 6.1 字段上移（Pull up Field）

## 6.2 函数上移（Pull up Method）

## 6.3 构造函数本体上移（Pull up Constructor Body）

## 6.4 函数下移（Push down Method）

## 6.5 字段下移（Push down Field）

## 6.6 提炼子类（Extract Subclass）

## 6.7 提炼超类（Extract Superclass）

## 6.8 提炼接口（Extract Interface）

## 6.9 折叠继承体系（Collapse Hierarchy）

## 6.10 塑造模板函数（Form Template Method）

## 6.11 以委托取代继承（Replace Inheritance with Delegation）

## 6.12 以继承取代委托（Replace Delegation with Inheritance）

# 7 大型重构

## 7.1 梳理并分解继承体系（Tease Apart Inheritance）

## 7.2 将过程化设计转化为对象设计（Convert Procedural Design to Objects）

## 7.3 将领域和表述/显示分离（Separate Domain from Presentation）

## 7.4 提炼继承体系（Extract Hierarchy）
